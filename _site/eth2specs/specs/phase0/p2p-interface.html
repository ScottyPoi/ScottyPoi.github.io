<h1> SSZ SimpleSerialize </h1>
<nav>
    <ul>
        
            <li><a href="/" title="SSZ Home Page">Home</a></li>
        
            <li><a href="/about" title="What is SSZ">About</a></li>
        
            <li><a href="/eth2specs/ssz/simple-serialize" title="SSZ Technical Specifications">Specs</a></li>
        
    </ul>
</nav>
<p>  </p>

<h1 id="ethereum-20-networking-specification">Ethereum 2.0 networking specification</h1>

<p>This document contains the networking specification for Ethereum 2.0 clients.</p>

<p>It consists of four main sections:</p>

<ol>
  <li>A specification of the network fundamentals.</li>
  <li>A specification of the three network interaction <em>domains</em> of Eth2: (a) the gossip domain, (b) the discovery domain, and (c) the Req/Resp domain.</li>
  <li>The rationale and further explanation for the design choices made in the previous two sections.</li>
  <li>An analysis of the maturity/state of the libp2p features required by this spec across the languages in which Eth2 clients are being developed.</li>
</ol>

<h2 id="table-of-contents">Table of contents</h2>
<!-- TOC -->
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

<ul>
  <li><a href="#network-fundamentals">Network fundamentals</a>
    <ul>
      <li><a href="#transport">Transport</a></li>
      <li><a href="#encryption-and-identification">Encryption and identification</a></li>
      <li><a href="#protocol-negotiation">Protocol Negotiation</a></li>
      <li><a href="#multiplexing">Multiplexing</a></li>
    </ul>
  </li>
  <li><a href="#eth2-network-interaction-domains">Eth2 network interaction domains</a>
    <ul>
      <li><a href="#configuration">Configuration</a></li>
      <li><a href="#metadata">MetaData</a></li>
      <li><a href="#the-gossip-domain-gossipsub">The gossip domain: gossipsub</a>
        <ul>
          <li><a href="#topics-and-messages">Topics and messages</a>
            <ul>
              <li><a href="#global-topics">Global topics</a>
                <ul>
                  <li><a href="#beacon_block"><code class="language-plaintext highlighter-rouge">beacon_block</code></a></li>
                  <li><a href="#beacon_aggregate_and_proof"><code class="language-plaintext highlighter-rouge">beacon_aggregate_and_proof</code></a></li>
                  <li><a href="#voluntary_exit"><code class="language-plaintext highlighter-rouge">voluntary_exit</code></a></li>
                  <li><a href="#proposer_slashing"><code class="language-plaintext highlighter-rouge">proposer_slashing</code></a></li>
                  <li><a href="#attester_slashing"><code class="language-plaintext highlighter-rouge">attester_slashing</code></a></li>
                </ul>
              </li>
              <li><a href="#attestation-subnets">Attestation subnets</a>
                <ul>
                  <li><a href="#beacon_attestation_subnet_id"><code class="language-plaintext highlighter-rouge">beacon_attestation_{subnet_id}</code></a></li>
                </ul>
              </li>
              <li><a href="#attestations-and-aggregation">Attestations and Aggregation</a></li>
            </ul>
          </li>
          <li><a href="#encodings">Encodings</a></li>
        </ul>
      </li>
      <li><a href="#the-reqresp-domain">The Req/Resp domain</a>
        <ul>
          <li><a href="#protocol-identification">Protocol identification</a></li>
          <li><a href="#reqresp-interaction">Req/Resp interaction</a>
            <ul>
              <li><a href="#requesting-side">Requesting side</a></li>
              <li><a href="#responding-side">Responding side</a></li>
            </ul>
          </li>
          <li><a href="#encoding-strategies">Encoding strategies</a>
            <ul>
              <li><a href="#ssz-snappy-encoding-strategy">SSZ-snappy encoding strategy</a></li>
            </ul>
          </li>
          <li><a href="#messages">Messages</a>
            <ul>
              <li><a href="#status">Status</a></li>
              <li><a href="#goodbye">Goodbye</a></li>
              <li><a href="#beaconblocksbyrange">BeaconBlocksByRange</a></li>
              <li><a href="#beaconblocksbyroot">BeaconBlocksByRoot</a></li>
              <li><a href="#ping">Ping</a></li>
              <li><a href="#getmetadata">GetMetaData</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#the-discovery-domain-discv5">The discovery domain: discv5</a>
        <ul>
          <li><a href="#integration-into-libp2p-stacks">Integration into libp2p stacks</a></li>
          <li><a href="#enr-structure">ENR structure</a>
            <ul>
              <li><a href="#attestation-subnet-bitfield">Attestation subnet bitfield</a></li>
              <li><a href="#eth2-field"><code class="language-plaintext highlighter-rouge">eth2</code> field</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#design-decision-rationale">Design decision rationale</a>
    <ul>
      <li><a href="#transport-1">Transport</a>
        <ul>
          <li><a href="#why-are-we-defining-specific-transports">Why are we defining specific transports?</a></li>
          <li><a href="#can-clients-support-other-transportshandshakes-than-the-ones-mandated-by-the-spec">Can clients support other transports/handshakes than the ones mandated by the spec?</a></li>
          <li><a href="#what-are-the-advantages-of-using-tcpquicwebsockets">What are the advantages of using TCP/QUIC/Websockets?</a></li>
          <li><a href="#why-do-we-not-just-support-a-single-transport">Why do we not just support a single transport?</a></li>
          <li><a href="#why-are-we-not-using-quic-from-the-start">Why are we not using QUIC from the start?</a></li>
        </ul>
      </li>
      <li><a href="#multiplexing-1">Multiplexing</a>
        <ul>
          <li><a href="#why-are-we-using-mplexyamux">Why are we using mplex/yamux?</a></li>
        </ul>
      </li>
      <li><a href="#protocol-negotiation-1">Protocol Negotiation</a>
        <ul>
          <li><a href="#when-is-multiselect-20-due-and-why-do-we-plan-to-migrate-to-it">When is multiselect 2.0 due and why do we plan to migrate to it?</a></li>
          <li><a href="#what-is-the-difference-between-connection-level-and-stream-level-protocol-negotiation">What is the difference between connection-level and stream-level protocol negotiation?</a></li>
        </ul>
      </li>
      <li><a href="#encryption">Encryption</a>
        <ul>
          <li><a href="#why-are-we-not-supporting-secio">Why are we not supporting SecIO?</a></li>
          <li><a href="#why-are-we-using-noise">Why are we using Noise?</a></li>
          <li><a href="#why-are-we-using-encryption-at-all">Why are we using encryption at all?</a></li>
        </ul>
      </li>
      <li><a href="#gossipsub">Gossipsub</a>
        <ul>
          <li><a href="#why-are-we-using-a-pubsub-algorithm-for-block-and-attestation-propagation">Why are we using a pub/sub algorithm for block and attestation propagation?</a></li>
          <li><a href="#why-are-we-using-topics-to-segregate-encodings-yet-only-support-one-encoding">Why are we using topics to segregate encodings, yet only support one encoding?</a></li>
          <li><a href="#how-do-we-upgrade-gossip-channels-eg-changes-in-encoding-compression">How do we upgrade gossip channels (e.g. changes in encoding, compression)?</a></li>
          <li><a href="#why-must-all-clients-use-the-same-gossip-topic-instead-of-one-negotiated-between-each-peer-pair">Why must all clients use the same gossip topic instead of one negotiated between each peer pair?</a></li>
          <li><a href="#why-are-the-topics-strings-and-not-hashes">Why are the topics strings and not hashes?</a></li>
          <li><a href="#why-are-we-using-the-strictnosign-signature-policy">Why are we using the <code class="language-plaintext highlighter-rouge">StrictNoSign</code> signature policy?</a></li>
          <li><a href="#why-are-we-overriding-the-default-libp2p-pubsub-message-id">Why are we overriding the default libp2p pubsub <code class="language-plaintext highlighter-rouge">message-id</code>?</a></li>
          <li><a href="#why-are-these-specific-gossip-parameters-chosen">Why are these specific gossip parameters chosen?</a></li>
          <li><a href="#why-is-there-maximum_gossip_clock_disparity-when-validating-slot-ranges-of-messages-in-gossip-subnets">Why is there <code class="language-plaintext highlighter-rouge">MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> when validating slot ranges of messages in gossip subnets?</a></li>
          <li><a href="#why-are-there-attestation_subnet_count-attestation-subnets">Why are there <code class="language-plaintext highlighter-rouge">ATTESTATION_SUBNET_COUNT</code> attestation subnets?</a></li>
          <li><a href="#why-are-attestations-limited-to-be-broadcast-on-gossip-channels-within-slots_per_epoch-slots">Why are attestations limited to be broadcast on gossip channels within <code class="language-plaintext highlighter-rouge">SLOTS_PER_EPOCH</code> slots?</a></li>
          <li><a href="#why-are-aggregate-attestations-broadcast-to-the-global-topic-as-aggregateandproofs-rather-than-just-as-attestations">Why are aggregate attestations broadcast to the global topic as <code class="language-plaintext highlighter-rouge">AggregateAndProof</code>s rather than just as <code class="language-plaintext highlighter-rouge">Attestation</code>s?</a></li>
          <li><a href="#why-are-we-sending-entire-objects-in-the-pubsub-and-not-just-hashes">Why are we sending entire objects in the pubsub and not just hashes?</a></li>
          <li><a href="#should-clients-gossip-blocks-if-they-cannot-validate-the-proposer-signature-due-to-not-yet-being-synced-not-knowing-the-head-block-etc">Should clients gossip blocks if they <em>cannot</em> validate the proposer signature due to not yet being synced, not knowing the head block, etc?</a></li>
          <li><a href="#how-are-we-going-to-discover-peers-in-a-gossipsub-topic">How are we going to discover peers in a gossipsub topic?</a></li>
          <li><a href="#how-should-fork-version-be-used-in-practice">How should fork version be used in practice?</a></li>
        </ul>
      </li>
      <li><a href="#reqresp">Req/Resp</a>
        <ul>
          <li><a href="#why-segregate-requests-into-dedicated-protocol-ids">Why segregate requests into dedicated protocol IDs?</a></li>
          <li><a href="#why-are-messages-length-prefixed-with-a-protobuf-varint-in-the-ssz-encoding">Why are messages length-prefixed with a protobuf varint in the SSZ-encoding?</a></li>
          <li><a href="#why-do-we-version-protocol-strings-with-ordinals-instead-of-semver">Why do we version protocol strings with ordinals instead of semver?</a></li>
          <li><a href="#why-is-it-called-reqresp-and-not-rpc">Why is it called Req/Resp and not RPC?</a></li>
          <li><a href="#why-do-we-allow-empty-responses-in-block-requests">Why do we allow empty responses in block requests?</a></li>
          <li><a href="#why-does-beaconblocksbyrange-let-the-server-choose-which-branch-to-send-blocks-from">Why does <code class="language-plaintext highlighter-rouge">BeaconBlocksByRange</code> let the server choose which branch to send blocks from?</a></li>
          <li><a href="#whats-the-effect-of-empty-slots-on-the-sync-algorithm">What’s the effect of empty slots on the sync algorithm?</a></li>
        </ul>
      </li>
      <li><a href="#discovery">Discovery</a>
        <ul>
          <li><a href="#why-are-we-using-discv5-and-not-libp2p-kademlia-dht">Why are we using discv5 and not libp2p Kademlia DHT?</a></li>
          <li><a href="#what-is-the-difference-between-an-enr-and-a-multiaddr-and-why-are-we-using-enrs">What is the difference between an ENR and a multiaddr, and why are we using ENRs?</a></li>
          <li><a href="#why-do-we-not-form-enrs-and-find-peers-until-genesis-blockstate-is-known">Why do we not form ENRs and find peers until genesis block/state is known?</a></li>
        </ul>
      </li>
      <li><a href="#compressionencoding">Compression/Encoding</a>
        <ul>
          <li><a href="#why-are-we-using-ssz-for-encoding">Why are we using SSZ for encoding?</a></li>
          <li><a href="#why-are-we-compressing-and-at-which-layers">Why are we compressing, and at which layers?</a></li>
          <li><a href="#why-are-using-snappy-for-compression">Why are using Snappy for compression?</a></li>
          <li><a href="#can-i-get-access-to-unencrypted-bytes-on-the-wire-for-debugging-purposes">Can I get access to unencrypted bytes on the wire for debugging purposes?</a></li>
          <li><a href="#what-are-ssz-type-size-bounds">What are SSZ type size bounds?</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#libp2p-implementations-matrix">libp2p implementations matrix</a></li>
</ul>

<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<!-- /TOC -->

<h1 id="network-fundamentals">Network fundamentals</h1>

<p>This section outlines the specification for the networking stack in Ethereum 2.0 clients.</p>

<h2 id="transport">Transport</h2>

<p>Even though libp2p is a multi-transport stack (designed to listen on multiple simultaneous transports and endpoints transparently),
we hereby define a profile for basic interoperability.</p>

<p>All implementations MUST support the TCP libp2p transport, and it MUST be enabled for both dialing and listening (i.e. outbound and inbound connections).
The libp2p TCP transport supports listening on IPv4 and IPv6 addresses (and on multiple simultaneously).</p>

<p>Clients must support listening on at least one of IPv4 or IPv6.
Clients that do <em>not</em> have support for listening on IPv4 SHOULD be cognizant of the potential disadvantages in terms of
Internet-wide routability/support. Clients MAY choose to listen only on IPv6, but MUST be capable of dialing both IPv4 and IPv6 addresses.</p>

<p>All listening endpoints must be publicly dialable, and thus not rely on libp2p circuit relay, AutoNAT, or AutoRelay facilities.
(Usage of circuit relay, AutoNAT, or AutoRelay will be specifically re-examined soon.)</p>

<p>Nodes operating behind a NAT, or otherwise undialable by default (e.g. container runtime, firewall, etc.),
MUST have their infrastructure configured to enable inbound traffic on the announced public listening endpoint.</p>

<h2 id="encryption-and-identification">Encryption and identification</h2>

<p>The <a href="https://github.com/libp2p/specs/tree/master/noise">Libp2p-noise</a> secure
channel handshake with <code class="language-plaintext highlighter-rouge">secp256k1</code> identities will be used for encryption.</p>

<p>As specified in the libp2p specification, clients MUST support the <code class="language-plaintext highlighter-rouge">XX</code> handshake pattern.</p>

<h2 id="protocol-negotiation">Protocol Negotiation</h2>

<p>Clients MUST use exact equality when negotiating protocol versions to use and MAY use the version to give priority to higher version numbers.</p>

<p>Clients MUST support <a href="https://github.com/multiformats/multistream-select/">multistream-select 1.0</a>
and MAY support <a href="https://github.com/libp2p/specs/pull/95">multiselect 2.0</a> when the spec solidifies.
Once all clients have implementations for multiselect 2.0, multistream-select 1.0 MAY be phased out.</p>

<h2 id="multiplexing">Multiplexing</h2>

<p>During connection bootstrapping, libp2p dynamically negotiates a mutually supported multiplexing method to conduct parallel conversations.
This applies to transports that are natively incapable of multiplexing (e.g. TCP, WebSockets, WebRTC),
and is omitted for capable transports (e.g. QUIC).</p>

<p>Two multiplexers are commonplace in libp2p implementations:
<a href="https://github.com/libp2p/specs/tree/master/mplex">mplex</a> and <a href="https://github.com/hashicorp/yamux/blob/master/spec.md">yamux</a>.
Their protocol IDs are, respectively: <code class="language-plaintext highlighter-rouge">/mplex/6.7.0</code> and <code class="language-plaintext highlighter-rouge">/yamux/1.0.0</code>.</p>

<p>Clients MUST support <a href="https://github.com/libp2p/specs/tree/master/mplex">mplex</a>
and MAY support <a href="https://github.com/hashicorp/yamux/blob/master/spec.md">yamux</a>.
If both are supported by the client, yamux MUST take precedence during negotiation.
See the <a href="#design-decision-rationale">Rationale</a> section below for tradeoffs.</p>

<h1 id="eth2-network-interaction-domains">Eth2 network interaction domains</h1>

<h2 id="configuration">Configuration</h2>

<p>This section outlines constants that are used in this spec.</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Value</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GOSSIP_MAX_SIZE</code></td>
      <td><code class="language-plaintext highlighter-rouge">2**20</code> (= 1048576, 1 MiB)</td>
      <td>The maximum allowed size of uncompressed gossip messages.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MAX_REQUEST_BLOCKS</code></td>
      <td><code class="language-plaintext highlighter-rouge">2**10</code> (= 1024)</td>
      <td>Maximum number of blocks in a single request</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MAX_CHUNK_SIZE</code></td>
      <td><code class="language-plaintext highlighter-rouge">2**20</code> (1048576, 1 MiB)</td>
      <td>The maximum allowed size of uncompressed req/resp chunked responses.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">TTFB_TIMEOUT</code></td>
      <td><code class="language-plaintext highlighter-rouge">5s</code></td>
      <td>The maximum time to wait for first byte of request response (time-to-first-byte).</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">RESP_TIMEOUT</code></td>
      <td><code class="language-plaintext highlighter-rouge">10s</code></td>
      <td>The maximum time for complete response transfer.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ATTESTATION_PROPAGATION_SLOT_RANGE</code></td>
      <td><code class="language-plaintext highlighter-rouge">32</code></td>
      <td>The maximum number of slots during which an attestation can be propagated.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MAXIMUM_GOSSIP_CLOCK_DISPARITY</code></td>
      <td><code class="language-plaintext highlighter-rouge">500ms</code></td>
      <td>The maximum milliseconds of clock disparity assumed between honest nodes.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MESSAGE_DOMAIN_INVALID_SNAPPY</code></td>
      <td><code class="language-plaintext highlighter-rouge">0x00000000</code></td>
      <td>4-byte domain for gossip message-id isolation of <em>invalid</em> snappy messages</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MESSAGE_DOMAIN_VALID_SNAPPY</code></td>
      <td><code class="language-plaintext highlighter-rouge">0x01000000</code></td>
      <td>4-byte domain for gossip message-id isolation of <em>valid</em> snappy messages</td>
    </tr>
  </tbody>
</table>

<h2 id="metadata">MetaData</h2>

<p>Clients MUST locally store the following <code class="language-plaintext highlighter-rouge">MetaData</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(
  seq_number: uint64
  attnets: Bitvector[ATTESTATION_SUBNET_COUNT]
)
</code></pre></div></div>

<p>Where</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">seq_number</code> is a <code class="language-plaintext highlighter-rouge">uint64</code> starting at <code class="language-plaintext highlighter-rouge">0</code> used to version the node’s metadata.
If any other field in the local <code class="language-plaintext highlighter-rouge">MetaData</code> changes, the node MUST increment <code class="language-plaintext highlighter-rouge">seq_number</code> by 1.</li>
  <li><code class="language-plaintext highlighter-rouge">attnets</code> is a <code class="language-plaintext highlighter-rouge">Bitvector</code> representing the node’s persistent attestation subnet subscriptions.</li>
</ul>

<p><em>Note</em>: <code class="language-plaintext highlighter-rouge">MetaData.seq_number</code> is used for versioning of the node’s metadata,
is entirely independent of the ENR sequence number,
and will in most cases be out of sync with the ENR sequence number.</p>

<h2 id="the-gossip-domain-gossipsub">The gossip domain: gossipsub</h2>

<p>Clients MUST support the <a href="https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.0.md">gossipsub v1</a> libp2p Protocol
including the <a href="https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md">gossipsub v1.1</a> extension.</p>

<p><strong>Protocol ID:</strong> <code class="language-plaintext highlighter-rouge">/meshsub/1.1.0</code></p>

<p><strong>Gossipsub Parameters</strong></p>

<p>The following gossipsub <a href="https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.0.md#parameters">parameters</a> will be used:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">D</code> (topic stable mesh target count): 8</li>
  <li><code class="language-plaintext highlighter-rouge">D_low</code> (topic stable mesh low watermark): 6</li>
  <li><code class="language-plaintext highlighter-rouge">D_high</code> (topic stable mesh high watermark): 12</li>
  <li><code class="language-plaintext highlighter-rouge">D_lazy</code> (gossip target): 6</li>
  <li><code class="language-plaintext highlighter-rouge">heartbeat_interval</code> (frequency of heartbeat, seconds): 0.7</li>
  <li><code class="language-plaintext highlighter-rouge">fanout_ttl</code> (ttl for fanout maps for topics we are not subscribed to but have published to, seconds): 60</li>
  <li><code class="language-plaintext highlighter-rouge">mcache_len</code> (number of windows to retain full messages in cache for <code class="language-plaintext highlighter-rouge">IWANT</code> responses): 6</li>
  <li><code class="language-plaintext highlighter-rouge">mcache_gossip</code> (number of windows to gossip about): 3</li>
  <li><code class="language-plaintext highlighter-rouge">seen_ttl</code> (number of heartbeat intervals to retain message IDs): 550</li>
</ul>

<p><em>Note</em>: Gossipsub v1.1 introduces a number of
<a href="https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md#overview-of-new-parameters">additional parameters</a>
for peer scoring and other attack mitigations.
These are currently under investigation and will be spec’d and released to mainnet when they are ready.</p>

<h3 id="topics-and-messages">Topics and messages</h3>

<p>Topics are plain UTF-8 strings and are encoded on the wire as determined by protobuf (gossipsub messages are enveloped in protobuf messages).
Topic strings have form: <code class="language-plaintext highlighter-rouge">/eth2/ForkDigestValue/Name/Encoding</code>.
This defines both the type of data being sent on the topic and how the data field of the message is encoded.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ForkDigestValue</code> - the lowercase hex-encoded (no “0x” prefix) bytes of <code class="language-plaintext highlighter-rouge">compute_fork_digest(current_fork_version, genesis_validators_root)</code> where
    <ul>
      <li><code class="language-plaintext highlighter-rouge">current_fork_version</code> is the fork version of the epoch of the message to be sent on the topic</li>
      <li><code class="language-plaintext highlighter-rouge">genesis_validators_root</code> is the static <code class="language-plaintext highlighter-rouge">Root</code> found in <code class="language-plaintext highlighter-rouge">state.genesis_validators_root</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Name</code> - see table below</li>
  <li><code class="language-plaintext highlighter-rouge">Encoding</code> - the encoding strategy describes a specific representation of bytes that will be transmitted over the wire.
See the <a href="#Encodings">Encodings</a> section for further details.</li>
</ul>

<p><em>Note</em>: <code class="language-plaintext highlighter-rouge">ForkDigestValue</code> is composed of values that are not known until the genesis block/state are available.
Due to this, clients SHOULD NOT subscribe to gossipsub topics until these genesis values are known.</p>

<p>Each gossipsub <a href="https://github.com/libp2p/go-libp2p-pubsub/blob/master/pb/rpc.proto#L17-L24">message</a> has a maximum size of <code class="language-plaintext highlighter-rouge">GOSSIP_MAX_SIZE</code>.
Clients MUST reject (fail validation) messages that are over this size limit.
Likewise, clients MUST NOT emit or propagate messages larger than this limit.</p>

<p>The optional <code class="language-plaintext highlighter-rouge">from</code> (1), <code class="language-plaintext highlighter-rouge">seqno</code> (3), <code class="language-plaintext highlighter-rouge">signature</code> (5) and <code class="language-plaintext highlighter-rouge">key</code> (6) protobuf fields are omitted from the message,
since messages are identified by content, anonymous, and signed where necessary in the application layer.
Starting from Gossipsub v1.1, clients MUST enforce this by applying the <code class="language-plaintext highlighter-rouge">StrictNoSign</code>
<a href="https://github.com/libp2p/specs/blob/master/pubsub/README.md#signature-policy-options">signature policy</a>.</p>

<p>The <code class="language-plaintext highlighter-rouge">message-id</code> of a gossipsub message MUST be the following 20 byte value computed from the message data:</p>
<ul>
  <li>If <code class="language-plaintext highlighter-rouge">message.data</code> has a valid snappy decompression, set <code class="language-plaintext highlighter-rouge">message-id</code> to the first 20 bytes of the <code class="language-plaintext highlighter-rouge">SHA256</code> hash of
the concatenation of <code class="language-plaintext highlighter-rouge">MESSAGE_DOMAIN_VALID_SNAPPY</code> with the snappy decompressed message data,
i.e. <code class="language-plaintext highlighter-rouge">SHA256(MESSAGE_DOMAIN_VALID_SNAPPY + snappy_decompress(message.data))[:20]</code>.</li>
  <li>Otherwise, set <code class="language-plaintext highlighter-rouge">message-id</code> to the first 20 bytes of the <code class="language-plaintext highlighter-rouge">SHA256</code> hash of
the concatenation of <code class="language-plaintext highlighter-rouge">MESSAGE_DOMAIN_INVALID_SNAPPY</code> with the raw message data,
i.e. <code class="language-plaintext highlighter-rouge">SHA256(MESSAGE_DOMAIN_INVALID_SNAPPY + message.data)[:20]</code>.</li>
</ul>

<p><em>Note</em>: The above logic handles two exceptional cases:
(1) multiple snappy <code class="language-plaintext highlighter-rouge">data</code> can decompress to the same value,
and (2) some message <code class="language-plaintext highlighter-rouge">data</code> can fail to snappy decompress altogether.</p>

<p>The payload is carried in the <code class="language-plaintext highlighter-rouge">data</code> field of a gossipsub message, and varies depending on the topic:</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Message Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">beacon_block</code></td>
      <td><code class="language-plaintext highlighter-rouge">SignedBeaconBlock</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">beacon_aggregate_and_proof</code></td>
      <td><code class="language-plaintext highlighter-rouge">SignedAggregateAndProof</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">beacon_attestation_{subnet_id}</code></td>
      <td><code class="language-plaintext highlighter-rouge">Attestation</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">voluntary_exit</code></td>
      <td><code class="language-plaintext highlighter-rouge">SignedVoluntaryExit</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">proposer_slashing</code></td>
      <td><code class="language-plaintext highlighter-rouge">ProposerSlashing</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">attester_slashing</code></td>
      <td><code class="language-plaintext highlighter-rouge">AttesterSlashing</code></td>
    </tr>
  </tbody>
</table>

<p>Clients MUST reject (fail validation) messages containing an incorrect type, or invalid payload.</p>

<p>When processing incoming gossip, clients MAY descore or disconnect peers who fail to observe these constraints.</p>

<p>For any optional queueing, clients SHOULD maintain maximum queue sizes to avoid DoS vectors.</p>

<p>Gossipsub v1.1 introduces <a href="https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md#extended-validators">Extended Validators</a>
for the application to aid in the gossipsub peer-scoring scheme.
We utilize <code class="language-plaintext highlighter-rouge">ACCEPT</code>, <code class="language-plaintext highlighter-rouge">REJECT</code>, and <code class="language-plaintext highlighter-rouge">IGNORE</code>. For each gossipsub topic, there are application specific validations.
If all validations pass, return <code class="language-plaintext highlighter-rouge">ACCEPT</code>.
If one or more validations fail while processing the items in order, return either <code class="language-plaintext highlighter-rouge">REJECT</code> or <code class="language-plaintext highlighter-rouge">IGNORE</code> as specified in the prefix of the particular condition.</p>

<h4 id="global-topics">Global topics</h4>

<p>There are two primary global topics used to propagate beacon blocks (<code class="language-plaintext highlighter-rouge">beacon_block</code>)
and aggregate attestations (<code class="language-plaintext highlighter-rouge">beacon_aggregate_and_proof</code>) to all nodes on the network.</p>

<p>There are three additional global topics are used to propagate lower frequency validator messages
(<code class="language-plaintext highlighter-rouge">voluntary_exit</code>, <code class="language-plaintext highlighter-rouge">proposer_slashing</code>, and <code class="language-plaintext highlighter-rouge">attester_slashing</code>).</p>

<h5 id="beacon_block"><code class="language-plaintext highlighter-rouge">beacon_block</code></h5>

<p>The <code class="language-plaintext highlighter-rouge">beacon_block</code> topic is used solely for propagating new signed beacon blocks to all nodes on the networks.
Signed blocks are sent in their entirety.</p>

<p>The following validations MUST pass before forwarding the <code class="language-plaintext highlighter-rouge">signed_beacon_block</code> on the network.</p>
<ul>
  <li><em>[IGNORE]</em> The block is not from a future slot (with a <code class="language-plaintext highlighter-rouge">MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) –
i.e. validate that <code class="language-plaintext highlighter-rouge">signed_beacon_block.message.slot &lt;= current_slot</code>
(a client MAY queue future blocks for processing at the appropriate slot).</li>
  <li><em>[IGNORE]</em> The block is from a slot greater than the latest finalized slot –
i.e. validate that <code class="language-plaintext highlighter-rouge">signed_beacon_block.message.slot &gt; compute_start_slot_at_epoch(state.finalized_checkpoint.epoch)</code>
(a client MAY choose to validate and store such blocks for additional purposes – e.g. slashing detection, archive nodes, etc).</li>
  <li><em>[IGNORE]</em> The block is the first block with valid signature received for the proposer for the slot, <code class="language-plaintext highlighter-rouge">signed_beacon_block.message.slot</code>.</li>
  <li><em>[REJECT]</em> The proposer signature, <code class="language-plaintext highlighter-rouge">signed_beacon_block.signature</code>, is valid with respect to the <code class="language-plaintext highlighter-rouge">proposer_index</code> pubkey.</li>
  <li><em>[IGNORE]</em> The block’s parent (defined by <code class="language-plaintext highlighter-rouge">block.parent_root</code>) has been seen
(via both gossip and non-gossip sources)
(a client MAY queue blocks for processing once the parent block is retrieved).</li>
  <li><em>[REJECT]</em> The block’s parent (defined by <code class="language-plaintext highlighter-rouge">block.parent_root</code>) passes validation.</li>
  <li><em>[REJECT]</em> The current <code class="language-plaintext highlighter-rouge">finalized_checkpoint</code> is an ancestor of <code class="language-plaintext highlighter-rouge">block</code> – i.e.
<code class="language-plaintext highlighter-rouge">get_ancestor(store, block.parent_root, compute_start_slot_at_epoch(store.finalized_checkpoint.epoch))
== store.finalized_checkpoint.root</code></li>
  <li><em>[REJECT]</em> The block is proposed by the expected <code class="language-plaintext highlighter-rouge">proposer_index</code> for the block’s slot
in the context of the current shuffling (defined by <code class="language-plaintext highlighter-rouge">parent_root</code>/<code class="language-plaintext highlighter-rouge">slot</code>).
If the <code class="language-plaintext highlighter-rouge">proposer_index</code> cannot immediately be verified against the expected shuffling,
the block MAY be queued for later processing while proposers for the block’s branch are calculated –
in such a case <em>do not</em> <code class="language-plaintext highlighter-rouge">REJECT</code>, instead <code class="language-plaintext highlighter-rouge">IGNORE</code> this message.</li>
</ul>

<h5 id="beacon_aggregate_and_proof"><code class="language-plaintext highlighter-rouge">beacon_aggregate_and_proof</code></h5>

<p>The <code class="language-plaintext highlighter-rouge">beacon_aggregate_and_proof</code> topic is used to propagate aggregated attestations (as <code class="language-plaintext highlighter-rouge">SignedAggregateAndProof</code>s)
to subscribing nodes (typically validators) to be included in future blocks.</p>

<p>The following validations MUST pass before forwarding the <code class="language-plaintext highlighter-rouge">signed_aggregate_and_proof</code> on the network.
(We define the following for convenience – <code class="language-plaintext highlighter-rouge">aggregate_and_proof = signed_aggregate_and_proof.message</code> and <code class="language-plaintext highlighter-rouge">aggregate = aggregate_and_proof.aggregate</code>)</p>
<ul>
  <li><em>[IGNORE]</em> <code class="language-plaintext highlighter-rouge">aggregate.data.slot</code> is within the last <code class="language-plaintext highlighter-rouge">ATTESTATION_PROPAGATION_SLOT_RANGE</code> slots (with a <code class="language-plaintext highlighter-rouge">MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) –
i.e. <code class="language-plaintext highlighter-rouge">aggregate.data.slot + ATTESTATION_PROPAGATION_SLOT_RANGE &gt;= current_slot &gt;= aggregate.data.slot</code>
(a client MAY queue future aggregates for processing at the appropriate slot).</li>
  <li><em>[REJECT]</em> The aggregate attestation’s epoch matches its target – i.e. <code class="language-plaintext highlighter-rouge">aggregate.data.target.epoch ==
compute_epoch_at_slot(aggregate.data.slot)</code></li>
  <li><em>[IGNORE]</em> The valid aggregate attestation defined by <code class="language-plaintext highlighter-rouge">hash_tree_root(aggregate)</code> has <em>not</em> already been seen
(via aggregate gossip, within a verified block, or through the creation of an equivalent aggregate locally).</li>
  <li><em>[IGNORE]</em> The <code class="language-plaintext highlighter-rouge">aggregate</code> is the first valid aggregate received for the aggregator
with index <code class="language-plaintext highlighter-rouge">aggregate_and_proof.aggregator_index</code> for the epoch <code class="language-plaintext highlighter-rouge">aggregate.data.target.epoch</code>.</li>
  <li><em>[REJECT]</em> The attestation has participants –
that is, <code class="language-plaintext highlighter-rouge">len(get_attesting_indices(state, aggregate.data, aggregate.aggregation_bits)) &gt;= 1</code>.</li>
  <li><em>[REJECT]</em> <code class="language-plaintext highlighter-rouge">aggregate_and_proof.selection_proof</code> selects the validator as an aggregator for the slot –
i.e. <code class="language-plaintext highlighter-rouge">is_aggregator(state, aggregate.data.slot, aggregate.data.index, aggregate_and_proof.selection_proof)</code> returns <code class="language-plaintext highlighter-rouge">True</code>.</li>
  <li><em>[REJECT]</em> The aggregator’s validator index is within the committee –
i.e. <code class="language-plaintext highlighter-rouge">aggregate_and_proof.aggregator_index in get_beacon_committee(state, aggregate.data.slot, aggregate.data.index)</code>.</li>
  <li><em>[REJECT]</em> The <code class="language-plaintext highlighter-rouge">aggregate_and_proof.selection_proof</code> is a valid signature
of the <code class="language-plaintext highlighter-rouge">aggregate.data.slot</code> by the validator with index <code class="language-plaintext highlighter-rouge">aggregate_and_proof.aggregator_index</code>.</li>
  <li><em>[REJECT]</em> The aggregator signature, <code class="language-plaintext highlighter-rouge">signed_aggregate_and_proof.signature</code>, is valid.</li>
  <li><em>[REJECT]</em> The signature of <code class="language-plaintext highlighter-rouge">aggregate</code> is valid.</li>
  <li><em>[IGNORE]</em> The block being voted for (<code class="language-plaintext highlighter-rouge">aggregate.data.beacon_block_root</code>) has been seen
(via both gossip and non-gossip sources)
(a client MAY queue aggregates for processing once block is retrieved).</li>
  <li><em>[REJECT]</em> The block being voted for (<code class="language-plaintext highlighter-rouge">aggregate.data.beacon_block_root</code>) passes validation.</li>
  <li><em>[REJECT]</em> The current <code class="language-plaintext highlighter-rouge">finalized_checkpoint</code> is an ancestor of the <code class="language-plaintext highlighter-rouge">block</code> defined by <code class="language-plaintext highlighter-rouge">aggregate.data.beacon_block_root</code> – i.e.
<code class="language-plaintext highlighter-rouge">get_ancestor(store, aggregate.data.beacon_block_root, compute_start_slot_at_epoch(store.finalized_checkpoint.epoch))
== store.finalized_checkpoint.root</code></li>
</ul>

<h5 id="voluntary_exit"><code class="language-plaintext highlighter-rouge">voluntary_exit</code></h5>

<p>The <code class="language-plaintext highlighter-rouge">voluntary_exit</code> topic is used solely for propagating signed voluntary validator exits to proposers on the network.
Signed voluntary exits are sent in their entirety.</p>

<p>The following validations MUST pass before forwarding the <code class="language-plaintext highlighter-rouge">signed_voluntary_exit</code> on to the network.</p>
<ul>
  <li><em>[IGNORE]</em> The voluntary exit is the first valid voluntary exit received
for the validator with index <code class="language-plaintext highlighter-rouge">signed_voluntary_exit.message.validator_index</code>.</li>
  <li><em>[REJECT]</em> All of the conditions within <code class="language-plaintext highlighter-rouge">process_voluntary_exit</code> pass validation.</li>
</ul>

<h5 id="proposer_slashing"><code class="language-plaintext highlighter-rouge">proposer_slashing</code></h5>

<p>The <code class="language-plaintext highlighter-rouge">proposer_slashing</code> topic is used solely for propagating proposer slashings to proposers on the network.
Proposer slashings are sent in their entirety.</p>

<p>The following validations MUST pass before forwarding the <code class="language-plaintext highlighter-rouge">proposer_slashing</code> on to the network.</p>
<ul>
  <li><em>[IGNORE]</em> The proposer slashing is the first valid proposer slashing received
for the proposer with index <code class="language-plaintext highlighter-rouge">proposer_slashing.signed_header_1.message.proposer_index</code>.</li>
  <li><em>[REJECT]</em> All of the conditions within <code class="language-plaintext highlighter-rouge">process_proposer_slashing</code> pass validation.</li>
</ul>

<h5 id="attester_slashing"><code class="language-plaintext highlighter-rouge">attester_slashing</code></h5>

<p>The <code class="language-plaintext highlighter-rouge">attester_slashing</code> topic is used solely for propagating attester slashings to proposers on the network.
Attester slashings are sent in their entirety.</p>

<p>Clients who receive an attester slashing on this topic MUST validate the conditions within <code class="language-plaintext highlighter-rouge">process_attester_slashing</code> before forwarding it across the network.</p>
<ul>
  <li><em>[IGNORE]</em> At least one index in the intersection of the attesting indices of each attestation
has not yet been seen in any prior <code class="language-plaintext highlighter-rouge">attester_slashing</code>
(i.e. <code class="language-plaintext highlighter-rouge">attester_slashed_indices = set(attestation_1.attesting_indices).intersection(attestation_2.attesting_indices)</code>,
verify if <code class="language-plaintext highlighter-rouge">any(attester_slashed_indices.difference(prior_seen_attester_slashed_indices))</code>).</li>
  <li><em>[REJECT]</em> All of the conditions within <code class="language-plaintext highlighter-rouge">process_attester_slashing</code> pass validation.</li>
</ul>

<h4 id="attestation-subnets">Attestation subnets</h4>

<p>Attestation subnets are used to propagate unaggregated attestations to subsections of the network.</p>

<h5 id="beacon_attestation_subnet_id"><code class="language-plaintext highlighter-rouge">beacon_attestation_{subnet_id}</code></h5>

<p>The <code class="language-plaintext highlighter-rouge">beacon_attestation_{subnet_id}</code> topics are used to propagate unaggregated attestations
to the subnet <code class="language-plaintext highlighter-rouge">subnet_id</code> (typically beacon and persistent committees) to be aggregated before being gossiped to <code class="language-plaintext highlighter-rouge">beacon_aggregate_and_proof</code>.</p>

<p>The following validations MUST pass before forwarding the <code class="language-plaintext highlighter-rouge">attestation</code> on the subnet.</p>
<ul>
  <li><em>[REJECT]</em> The committee index is within the expected range – i.e. <code class="language-plaintext highlighter-rouge">data.index &lt; get_committee_count_per_slot(state, data.target.epoch)</code>.</li>
  <li><em>[REJECT]</em> The attestation is for the correct subnet –
i.e. <code class="language-plaintext highlighter-rouge">compute_subnet_for_attestation(committees_per_slot, attestation.data.slot, attestation.data.index) == subnet_id</code>,
where <code class="language-plaintext highlighter-rouge">committees_per_slot = get_committee_count_per_slot(state, attestation.data.target.epoch)</code>,
which may be pre-computed along with the committee information for the signature check.</li>
  <li><em>[IGNORE]</em> <code class="language-plaintext highlighter-rouge">attestation.data.slot</code> is within the last <code class="language-plaintext highlighter-rouge">ATTESTATION_PROPAGATION_SLOT_RANGE</code> slots
(within a <code class="language-plaintext highlighter-rouge">MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) –
i.e. <code class="language-plaintext highlighter-rouge">attestation.data.slot + ATTESTATION_PROPAGATION_SLOT_RANGE &gt;= current_slot &gt;= attestation.data.slot</code>
(a client MAY queue future attestations for processing at the appropriate slot).</li>
  <li><em>[REJECT]</em> The attestation’s epoch matches its target – i.e. <code class="language-plaintext highlighter-rouge">attestation.data.target.epoch ==
compute_epoch_at_slot(attestation.data.slot)</code></li>
  <li><em>[REJECT]</em> The attestation is unaggregated –
that is, it has exactly one participating validator (<code class="language-plaintext highlighter-rouge">len([bit for bit in attestation.aggregation_bits if bit]) == 1</code>, i.e. exactly 1 bit is set).</li>
  <li><em>[REJECT]</em> The number of aggregation bits matches the committee size – i.e.
<code class="language-plaintext highlighter-rouge">len(attestation.aggregation_bits) == len(get_beacon_committee(state, data.slot, data.index))</code>.</li>
  <li><em>[IGNORE]</em> There has been no other valid attestation seen on an attestation subnet
that has an identical <code class="language-plaintext highlighter-rouge">attestation.data.target.epoch</code> and participating validator index.</li>
  <li><em>[REJECT]</em> The signature of <code class="language-plaintext highlighter-rouge">attestation</code> is valid.</li>
  <li><em>[IGNORE]</em> The block being voted for (<code class="language-plaintext highlighter-rouge">attestation.data.beacon_block_root</code>) has been seen
(via both gossip and non-gossip sources)
(a client MAY queue attestations for processing once block is retrieved).</li>
  <li><em>[REJECT]</em> The block being voted for (<code class="language-plaintext highlighter-rouge">attestation.data.beacon_block_root</code>) passes validation.</li>
  <li><em>[REJECT]</em> The attestation’s target block is an ancestor of the block named in the LMD vote – i.e.
<code class="language-plaintext highlighter-rouge">get_ancestor(store, attestation.data.beacon_block_root, compute_start_slot_at_epoch(attestation.data.target.epoch)) == attestation.data.target.root</code></li>
  <li><em>[REJECT]</em> The current <code class="language-plaintext highlighter-rouge">finalized_checkpoint</code> is an ancestor of the <code class="language-plaintext highlighter-rouge">block</code> defined by <code class="language-plaintext highlighter-rouge">attestation.data.beacon_block_root</code> – i.e.
<code class="language-plaintext highlighter-rouge">get_ancestor(store, attestation.data.beacon_block_root, compute_start_slot_at_epoch(store.finalized_checkpoint.epoch))
== store.finalized_checkpoint.root</code></li>
</ul>

<h4 id="attestations-and-aggregation">Attestations and Aggregation</h4>

<p>Attestation broadcasting is grouped into subnets defined by a topic.
The number of subnets is defined via <code class="language-plaintext highlighter-rouge">ATTESTATION_SUBNET_COUNT</code>.
The correct subnet for an attestation can be calculated with <code class="language-plaintext highlighter-rouge">compute_subnet_for_attestation</code>.
<code class="language-plaintext highlighter-rouge">beacon_attestation_{subnet_id}</code> topics, are rotated through throughout the epoch in a similar fashion to rotating through shards in committees in Phase 1.
The subnets are rotated through with <code class="language-plaintext highlighter-rouge">committees_per_slot = get_committee_count_per_slot(state, attestation.data.target.epoch)</code> subnets per slot.</p>

<p>Unaggregated attestations are sent as <code class="language-plaintext highlighter-rouge">Attestation</code>s to the subnet topic,
<code class="language-plaintext highlighter-rouge">beacon_attestation_{compute_subnet_for_attestation(committees_per_slot, attestation.data.slot, attestation.data.index)}</code> as <code class="language-plaintext highlighter-rouge">Attestation</code>s.</p>

<p>Aggregated attestations are sent to the <code class="language-plaintext highlighter-rouge">beacon_aggregate_and_proof</code> topic as <code class="language-plaintext highlighter-rouge">AggregateAndProof</code>s.</p>

<h3 id="encodings">Encodings</h3>

<p>Topics are post-fixed with an encoding. Encodings define how the payload of a gossipsub message is encoded.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ssz_snappy</code> - All objects are SSZ-encoded and then compressed with <a href="https://github.com/google/snappy">Snappy</a> block compression.
Example: The beacon aggregate attestation topic string is <code class="language-plaintext highlighter-rouge">/eth2/446a7232/beacon_aggregate_and_proof/ssz_snappy</code>,
the fork digest is <code class="language-plaintext highlighter-rouge">446a7232</code> and the data field of a gossipsub message is an <code class="language-plaintext highlighter-rouge">AggregateAndProof</code>
that has been SSZ-encoded and then compressed with Snappy.</li>
</ul>

<p>Snappy has two formats: “block” and “frames” (streaming).
Gossip messages remain relatively small (100s of bytes to 100s of kilobytes)
so <a href="https://github.com/google/snappy/blob/master/format_description.txt">basic snappy block compression</a> is used to avoid the additional overhead associated with snappy frames.</p>

<p>Implementations MUST use a single encoding for gossip.
Changing an encoding will require coordination between participating implementations.</p>

<h2 id="the-reqresp-domain">The Req/Resp domain</h2>

<h3 id="protocol-identification">Protocol identification</h3>

<p>Each message type is segregated into its own libp2p protocol ID, which is a case-sensitive UTF-8 string of the form:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/ProtocolPrefix/MessageName/SchemaVersion/Encoding
</code></pre></div></div>

<p>With:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ProtocolPrefix</code> - messages are grouped into families identified by a shared libp2p protocol name prefix.
In this case, we use <code class="language-plaintext highlighter-rouge">/eth2/beacon_chain/req</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">MessageName</code> - each request is identified by a name consisting of English alphabet, digits and underscores (<code class="language-plaintext highlighter-rouge">_</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">SchemaVersion</code> - an ordinal version number (e.g. 1, 2, 3…).
Each schema is versioned to facilitate backward and forward-compatibility when possible.</li>
  <li><code class="language-plaintext highlighter-rouge">Encoding</code> - while the schema defines the data types in more abstract terms,
the encoding strategy describes a specific representation of bytes that will be transmitted over the wire.
See the <a href="#Encoding-strategies">Encodings</a> section for further details.</li>
</ul>

<p>This protocol segregation allows libp2p <code class="language-plaintext highlighter-rouge">multistream-select 1.0</code> / <code class="language-plaintext highlighter-rouge">multiselect 2.0</code>
to handle the request type, version, and encoding negotiation before establishing the underlying streams.</p>

<h3 id="reqresp-interaction">Req/Resp interaction</h3>

<p>We use ONE stream PER request/response interaction.
Streams are closed when the interaction finishes, whether in success or in error.</p>

<p>Request/response messages MUST adhere to the encoding specified in the protocol name and follow this structure (relaxed BNF grammar):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>request   ::= &lt;encoding-dependent-header&gt; | &lt;encoded-payload&gt;
response  ::= &lt;response_chunk&gt;*
response_chunk  ::= &lt;result&gt; | &lt;encoding-dependent-header&gt; | &lt;encoded-payload&gt;
result    ::= “0” | “1” | “2” | [“128” ... ”255”]
</code></pre></div></div>

<p>The encoding-dependent header may carry metadata or assertions such as the encoded payload length, for integrity and attack proofing purposes.
Because req/resp streams are single-use and stream closures implicitly delimit the boundaries, it is not strictly necessary to length-prefix payloads;
however, certain encodings like SSZ do, for added security.</p>

<p>A <code class="language-plaintext highlighter-rouge">response</code> is formed by zero or more <code class="language-plaintext highlighter-rouge">response_chunk</code>s.
Responses that consist of a single SSZ-list (such as <code class="language-plaintext highlighter-rouge">BlocksByRange</code> and <code class="language-plaintext highlighter-rouge">BlocksByRoot</code>) send each list item as a <code class="language-plaintext highlighter-rouge">response_chunk</code>.
All other response types (non-Lists) send a single <code class="language-plaintext highlighter-rouge">response_chunk</code>.</p>

<p>For both <code class="language-plaintext highlighter-rouge">request</code>s and <code class="language-plaintext highlighter-rouge">response</code>s, the <code class="language-plaintext highlighter-rouge">encoding-dependent-header</code> MUST be valid,
and the <code class="language-plaintext highlighter-rouge">encoded-payload</code> must be valid within the constraints of the <code class="language-plaintext highlighter-rouge">encoding-dependent-header</code>.
This includes type-specific bounds on payload size for some encoding strategies.
Regardless of these type specific bounds, a global maximum uncompressed byte size of <code class="language-plaintext highlighter-rouge">MAX_CHUNK_SIZE</code> MUST be applied to all method response chunks.</p>

<p>Clients MUST ensure that lengths are within these bounds; if not, they SHOULD reset the stream immediately.
Clients tracking peer reputation MAY decrement the score of the misbehaving peer under this circumstance.</p>

<h4 id="requesting-side">Requesting side</h4>

<p>Once a new stream with the protocol ID for the request type has been negotiated, the full request message SHOULD be sent immediately.
The request MUST be encoded according to the encoding strategy.</p>

<p>The requester MUST close the write side of the stream once it finishes writing the request message.
At this point, the stream will be half-closed.</p>

<p>The requester MUST wait a maximum of <code class="language-plaintext highlighter-rouge">TTFB_TIMEOUT</code> for the first response byte to arrive (time to first byte—or TTFB—timeout).
On that happening, the requester allows a further <code class="language-plaintext highlighter-rouge">RESP_TIMEOUT</code> for each subsequent <code class="language-plaintext highlighter-rouge">response_chunk</code> received.</p>

<p>If any of these timeouts fire, the requester SHOULD reset the stream and deem the req/resp operation to have failed.</p>

<p>A requester SHOULD read from the stream until either:</p>
<ol>
  <li>An error result is received in one of the chunks (the error payload MAY be read before stopping).</li>
  <li>The responder closes the stream.</li>
  <li>Any part of the <code class="language-plaintext highlighter-rouge">response_chunk</code> fails validation.</li>
  <li>The maximum number of requested chunks are read.</li>
</ol>

<p>For requests consisting of a single valid <code class="language-plaintext highlighter-rouge">response_chunk</code>,
the requester SHOULD read the chunk fully, as defined by the <code class="language-plaintext highlighter-rouge">encoding-dependent-header</code>, before closing the stream.</p>

<h4 id="responding-side">Responding side</h4>

<p>Once a new stream with the protocol ID for the request type has been negotiated,
the responder SHOULD process the incoming request and MUST validate it before processing it.
Request processing and validation MUST be done according to the encoding strategy, until EOF (denoting stream half-closure by the requester).</p>

<p>The responder MUST:</p>

<ol>
  <li>Use the encoding strategy to read the optional header.</li>
  <li>If there are any length assertions for length <code class="language-plaintext highlighter-rouge">N</code>, it should read exactly <code class="language-plaintext highlighter-rouge">N</code> bytes from the stream, at which point an EOF should arise (no more bytes).
  Should this not be the case, it should be treated as a failure.</li>
  <li>Deserialize the expected type, and process the request.</li>
  <li>Write the response which may consist of zero or more <code class="language-plaintext highlighter-rouge">response_chunk</code>s (result, optional header, payload).</li>
  <li>Close their write side of the stream. At this point, the stream will be fully closed.</li>
</ol>

<p>If steps (1), (2), or (3) fail due to invalid, malformed, or inconsistent data, the responder MUST respond in error.
Clients tracking peer reputation MAY record such failures, as well as unexpected events, e.g. early stream resets.</p>

<p>The entire request should be read in no more than <code class="language-plaintext highlighter-rouge">RESP_TIMEOUT</code>.
Upon a timeout, the responder SHOULD reset the stream.</p>

<p>The responder SHOULD send a <code class="language-plaintext highlighter-rouge">response_chunk</code> promptly.
Chunks start with a <strong>single-byte</strong> response code which determines the contents of the <code class="language-plaintext highlighter-rouge">response_chunk</code> (<code class="language-plaintext highlighter-rouge">result</code> particle in the BNF grammar above).
For multiple chunks, only the last chunk is allowed to have a non-zero error code (i.e. The chunk stream is terminated once an error occurs).</p>

<p>The response code can have one of the following values, encoded as a single unsigned byte:</p>

<ul>
  <li>0: <strong>Success</strong> – a normal response follows, with contents matching the expected message schema and encoding specified in the request.</li>
  <li>1: <strong>InvalidRequest</strong> – the contents of the request are semantically invalid, or the payload is malformed, or could not be understood.
  The response payload adheres to the <code class="language-plaintext highlighter-rouge">ErrorMessage</code> schema (described below).</li>
  <li>2: <strong>ServerError</strong> – the responder encountered an error while processing the request.
  The response payload adheres to the <code class="language-plaintext highlighter-rouge">ErrorMessage</code> schema (described below).</li>
</ul>

<p>Clients MAY use response codes above <code class="language-plaintext highlighter-rouge">128</code> to indicate alternative, erroneous request-specific responses.</p>

<p>The range <code class="language-plaintext highlighter-rouge">[3, 127]</code> is RESERVED for future usages, and should be treated as error if not recognized expressly.</p>

<p>The <code class="language-plaintext highlighter-rouge">ErrorMessage</code> schema is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(
  error_message: List[byte, 256]
)
</code></pre></div></div>

<p><em>Note</em>: By convention, the <code class="language-plaintext highlighter-rouge">error_message</code> is a sequence of bytes that MAY be interpreted as a UTF-8 string (for debugging purposes).
Clients MUST treat as valid any byte sequences.</p>

<h3 id="encoding-strategies">Encoding strategies</h3>

<p>The token of the negotiated protocol ID specifies the type of encoding to be used for the req/resp interaction.
Only one value is possible at this time:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ssz_snappy</code>: The contents are first <a href="/eth2specs/ssz/simple-serialize.html">SSZ-encoded</a>
  and then compressed with <a href="https://github.com/google/snappy">Snappy</a> frames compression.
  For objects containing a single field, only the field is SSZ-encoded not a container with a single field.
  For example, the <code class="language-plaintext highlighter-rouge">BeaconBlocksByRoot</code> request is an SSZ-encoded list of <code class="language-plaintext highlighter-rouge">Root</code>’s.
  This encoding type MUST be supported by all clients.</li>
</ul>

<h4 id="ssz-snappy-encoding-strategy">SSZ-snappy encoding strategy</h4>

<p>The <a href="/eth2specs/ssz/simple-serialize.html">SimpleSerialize (SSZ) specification</a> outlines how objects are SSZ-encoded.</p>

<p>To achieve snappy encoding on top of SSZ, we feed the serialized form of the object to the Snappy compressor on encoding.
The inverse happens on decoding.</p>

<p>Snappy has two formats: “block” and “frames” (streaming).
To support large requests and response chunks, snappy-framing is used.</p>

<p>Since snappy frame contents <a href="https://github.com/google/snappy/blob/master/framing_format.txt#L104">have a maximum size of <code class="language-plaintext highlighter-rouge">65536</code> bytes</a>
and frame headers are just <code class="language-plaintext highlighter-rouge">identifier (1) + checksum (4)</code> bytes, the expected buffering of a single frame is acceptable.</p>

<p><strong>Encoding-dependent header:</strong> Req/Resp protocols using the <code class="language-plaintext highlighter-rouge">ssz_snappy</code> encoding strategy MUST encode the length of the raw SSZ bytes,
encoded as an unsigned <a href="https://developers.google.com/protocol-buffers/docs/encoding#varints">protobuf varint</a>.</p>

<p><em>Writing</em>: By first computing and writing the SSZ byte length, the SSZ encoder can then directly write the chunk contents to the stream.
When Snappy is applied, it can be passed through a buffered Snappy writer to compress frame by frame.</p>

<p><em>Reading</em>: After reading the expected SSZ byte length, the SSZ decoder can directly read the contents from the stream.
When snappy is applied, it can be passed through a buffered Snappy reader to decompress frame by frame.</p>

<p>Before reading the payload, the header MUST be validated:</p>
<ul>
  <li>The unsigned protobuf varint used for the length-prefix MUST not be longer than 10 bytes, which is sufficient for any <code class="language-plaintext highlighter-rouge">uint64</code>.</li>
  <li>The length-prefix is within the expected <a href="#what-are-ssz-type-size-bounds">size bounds derived from the payload SSZ type</a>.</li>
</ul>

<p>After reading a valid header, the payload MAY be read, while maintaining the size constraints from the header.</p>

<p>A reader SHOULD NOT read more than <code class="language-plaintext highlighter-rouge">max_encoded_len(n)</code> bytes after reading the SSZ length-prefix <code class="language-plaintext highlighter-rouge">n</code> from the header.</p>
<ul>
  <li>For <code class="language-plaintext highlighter-rouge">ssz_snappy</code> this is: <code class="language-plaintext highlighter-rouge">32 + n + n // 6</code>.
This is considered the <a href="https://github.com/google/snappy/blob/537f4ad6240e586970fe554614542e9717df7902/snappy.cc#L98">worst-case compression result</a> by Snappy.</li>
</ul>

<p>A reader SHOULD consider the following cases as invalid input:</p>
<ul>
  <li>Any remaining bytes, after having read the <code class="language-plaintext highlighter-rouge">n</code> SSZ bytes. An EOF is expected if more bytes are read than required.</li>
  <li>An early EOF, before fully reading the declared length-prefix worth of SSZ bytes.</li>
</ul>

<p>In case of an invalid input (header or payload), a reader MUST:</p>
<ul>
  <li>From requests: send back an error message, response code <code class="language-plaintext highlighter-rouge">InvalidRequest</code>. The request itself is ignored.</li>
  <li>From responses: ignore the response, the response MUST be considered bad server behavior.</li>
</ul>

<p>All messages that contain only a single field MUST be encoded directly as the type of that field and MUST NOT be encoded as an SSZ container.</p>

<p>Responses that are SSZ-lists (for example <code class="language-plaintext highlighter-rouge">List[SignedBeaconBlock, ...]</code>) send their
constituents individually as <code class="language-plaintext highlighter-rouge">response_chunk</code>s. For example, the
<code class="language-plaintext highlighter-rouge">List[SignedBeaconBlock, ...]</code> response type sends zero or more <code class="language-plaintext highlighter-rouge">response_chunk</code>s.
Each <em>successful</em> <code class="language-plaintext highlighter-rouge">response_chunk</code> contains a single <code class="language-plaintext highlighter-rouge">SignedBeaconBlock</code> payload.</p>

<h3 id="messages">Messages</h3>

<h4 id="status">Status</h4>

<p><strong>Protocol ID:</strong> <code class="language-plaintext highlighter-rouge">/eth2/beacon_chain/req/status/1/</code></p>

<p>Request, Response Content:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(
  fork_digest: ForkDigest
  finalized_root: Root
  finalized_epoch: Epoch
  head_root: Root
  head_slot: Slot
)
</code></pre></div></div>
<p>The fields are, as seen by the client at the time of sending the message:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fork_digest</code>: The node’s <code class="language-plaintext highlighter-rouge">ForkDigest</code> (<code class="language-plaintext highlighter-rouge">compute_fork_digest(current_fork_version, genesis_validators_root)</code>) where
    <ul>
      <li><code class="language-plaintext highlighter-rouge">current_fork_version</code> is the fork version at the node’s current epoch defined by the wall-clock time
(not necessarily the epoch to which the node is sync)</li>
      <li><code class="language-plaintext highlighter-rouge">genesis_validators_root</code> is the static <code class="language-plaintext highlighter-rouge">Root</code> found in <code class="language-plaintext highlighter-rouge">state.genesis_validators_root</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">finalized_root</code>: <code class="language-plaintext highlighter-rouge">state.finalized_checkpoint.root</code> for the state corresponding to the head block
(Note this defaults to <code class="language-plaintext highlighter-rouge">Root(b'\x00' * 32)</code> for the genesis finalized checkpoint).</li>
  <li><code class="language-plaintext highlighter-rouge">finalized_epoch</code>: <code class="language-plaintext highlighter-rouge">state.finalized_checkpoint.epoch</code> for the state corresponding to the head block.</li>
  <li><code class="language-plaintext highlighter-rouge">head_root</code>: The <code class="language-plaintext highlighter-rouge">hash_tree_root</code> root of the current head block (<code class="language-plaintext highlighter-rouge">BeaconBlock</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">head_slot</code>: The slot of the block corresponding to the <code class="language-plaintext highlighter-rouge">head_root</code>.</li>
</ul>

<p>The dialing client MUST send a <code class="language-plaintext highlighter-rouge">Status</code> request upon connection.</p>

<p>The request/response MUST be encoded as an SSZ-container.</p>

<p>The response MUST consist of a single <code class="language-plaintext highlighter-rouge">response_chunk</code>.</p>

<p>Clients SHOULD immediately disconnect from one another following the handshake above under the following conditions:</p>

<ol>
  <li>If <code class="language-plaintext highlighter-rouge">fork_digest</code> does not match the node’s local <code class="language-plaintext highlighter-rouge">fork_digest</code>, since the client’s chain is on another fork.</li>
  <li>If the (<code class="language-plaintext highlighter-rouge">finalized_root</code>, <code class="language-plaintext highlighter-rouge">finalized_epoch</code>) shared by the peer is not in the client’s chain at the expected epoch.
  For example, if Peer 1 sends (root, epoch) of (A, 5) and Peer 2 sends (B, 3) but Peer 1 has root C at epoch 3,
  then Peer 1 would disconnect because it knows that their chains are irreparably disjoint.</li>
</ol>

<p>Once the handshake completes, the client with the lower <code class="language-plaintext highlighter-rouge">finalized_epoch</code> or <code class="language-plaintext highlighter-rouge">head_slot</code> (if the clients have equal <code class="language-plaintext highlighter-rouge">finalized_epoch</code>s)
SHOULD request beacon blocks from its counterparty via the <code class="language-plaintext highlighter-rouge">BeaconBlocksByRange</code> request.</p>

<p><em>Note</em>: Under abnormal network condition or after some rounds of <code class="language-plaintext highlighter-rouge">BeaconBlocksByRange</code> requests,
the client might need to send <code class="language-plaintext highlighter-rouge">Status</code> request again to learn if the peer has a higher head.
Implementers are free to implement such behavior in their own way.</p>

<h4 id="goodbye">Goodbye</h4>

<p><strong>Protocol ID:</strong> <code class="language-plaintext highlighter-rouge">/eth2/beacon_chain/req/goodbye/1/</code></p>

<p>Request, Response Content:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(
  uint64
)
</code></pre></div></div>
<p>Client MAY send goodbye messages upon disconnection. The reason field MAY be one of the following values:</p>

<ul>
  <li>1: Client shut down.</li>
  <li>2: Irrelevant network.</li>
  <li>3: Fault/error.</li>
</ul>

<p>Clients MAY use reason codes above <code class="language-plaintext highlighter-rouge">128</code> to indicate alternative, erroneous request-specific responses.</p>

<p>The range <code class="language-plaintext highlighter-rouge">[4, 127]</code> is RESERVED for future usage.</p>

<p>The request/response MUST be encoded as a single SSZ-field.</p>

<p>The response MUST consist of a single <code class="language-plaintext highlighter-rouge">response_chunk</code>.</p>

<h4 id="beaconblocksbyrange">BeaconBlocksByRange</h4>

<p><strong>Protocol ID:</strong> <code class="language-plaintext highlighter-rouge">/eth2/beacon_chain/req/beacon_blocks_by_range/1/</code></p>

<p>Request Content:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(
  start_slot: Slot
  count: uint64
  step: uint64
)
</code></pre></div></div>

<p>Response Content:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(
  List[SignedBeaconBlock, MAX_REQUEST_BLOCKS]
)
</code></pre></div></div>

<p>Requests beacon blocks in the slot range <code class="language-plaintext highlighter-rouge">[start_slot, start_slot + count * step)</code>, leading up to the current head block as selected by fork choice.
<code class="language-plaintext highlighter-rouge">step</code> defines the slot increment between blocks.
For example, requesting blocks starting at <code class="language-plaintext highlighter-rouge">start_slot</code> 2 with a step value of 2 would return the blocks at slots [2, 4, 6, …].
In cases where a slot is empty for a given slot number, no block is returned.
For example, if slot 4 were empty in the previous example, the returned array would contain [2, 6, …].
A request MUST NOT have a 0 slot increment, i.e. <code class="language-plaintext highlighter-rouge">step &gt;= 1</code>.</p>

<p><code class="language-plaintext highlighter-rouge">BeaconBlocksByRange</code> is primarily used to sync historical blocks.</p>

<p>The request MUST be encoded as an SSZ-container.</p>

<p>The response MUST consist of zero or more <code class="language-plaintext highlighter-rouge">response_chunk</code>.
Each <em>successful</em> <code class="language-plaintext highlighter-rouge">response_chunk</code> MUST contain a single <code class="language-plaintext highlighter-rouge">SignedBeaconBlock</code> payload.</p>

<p>Clients MUST keep a record of signed blocks seen since the start of the weak subjectivity period
and MUST support serving requests of blocks up to their own <code class="language-plaintext highlighter-rouge">head_block_root</code>.</p>

<p>Clients MUST respond with at least the first block that exists in the range, if they have it, and no more than <code class="language-plaintext highlighter-rouge">MAX_REQUEST_BLOCKS</code> blocks.</p>

<p>The following blocks, where they exist, MUST be sent in consecutive order.</p>

<p>Clients MAY limit the number of blocks in the response.</p>

<p>The response MUST contain no more than <code class="language-plaintext highlighter-rouge">count</code> blocks.</p>

<p>Clients MUST respond with blocks from their view of the current fork choice
– that is, blocks from the single chain defined by the current head.
Of note, blocks from slots before the finalization MUST lead to the finalized block reported in the <code class="language-plaintext highlighter-rouge">Status</code> handshake.</p>

<p>Clients MUST respond with blocks that are consistent from a single chain within the context of the request.
This applies to any <code class="language-plaintext highlighter-rouge">step</code> value.
In particular when <code class="language-plaintext highlighter-rouge">step == 1</code>, each <code class="language-plaintext highlighter-rouge">parent_root</code> MUST match the <code class="language-plaintext highlighter-rouge">hash_tree_root</code> of the preceding block.</p>

<p>After the initial block, clients MAY stop in the process of responding
if their fork choice changes the view of the chain in the context of the request.</p>

<h4 id="beaconblocksbyroot">BeaconBlocksByRoot</h4>

<p><strong>Protocol ID:</strong> <code class="language-plaintext highlighter-rouge">/eth2/beacon_chain/req/beacon_blocks_by_root/1/</code></p>

<p>Request Content:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(
  List[Root, MAX_REQUEST_BLOCKS]
)
</code></pre></div></div>

<p>Response Content:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(
  List[SignedBeaconBlock, MAX_REQUEST_BLOCKS]
)
</code></pre></div></div>

<p>Requests blocks by block root (= <code class="language-plaintext highlighter-rouge">hash_tree_root(SignedBeaconBlock.message)</code>).
The response is a list of <code class="language-plaintext highlighter-rouge">SignedBeaconBlock</code> whose length is less than or equal to the number of requested blocks.
It may be less in the case that the responding peer is missing blocks.</p>

<p>No more than <code class="language-plaintext highlighter-rouge">MAX_REQUEST_BLOCKS</code> may be requested at a time.</p>

<p><code class="language-plaintext highlighter-rouge">BeaconBlocksByRoot</code> is primarily used to recover recent blocks (e.g. when receiving a block or attestation whose parent is unknown).</p>

<p>The request MUST be encoded as an SSZ-field.</p>

<p>The response MUST consist of zero or more <code class="language-plaintext highlighter-rouge">response_chunk</code>.
Each <em>successful</em> <code class="language-plaintext highlighter-rouge">response_chunk</code> MUST contain a single <code class="language-plaintext highlighter-rouge">SignedBeaconBlock</code> payload.</p>

<p>Clients MUST support requesting blocks since the latest finalized epoch.</p>

<p>Clients MUST respond with at least one block, if they have it.
Clients MAY limit the number of blocks in the response.</p>

<h4 id="ping">Ping</h4>

<p><strong>Protocol ID:</strong> <code class="language-plaintext highlighter-rouge">/eth2/beacon_chain/req/ping/1/</code></p>

<p>Request Content:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(
  uint64
)
</code></pre></div></div>

<p>Response Content:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(
  uint64
)
</code></pre></div></div>

<p>Sent intermittently, the <code class="language-plaintext highlighter-rouge">Ping</code> protocol checks liveness of connected peers.
Peers request and respond with their local metadata sequence number (<code class="language-plaintext highlighter-rouge">MetaData.seq_number</code>).</p>

<p>If the peer does not respond to the <code class="language-plaintext highlighter-rouge">Ping</code> request, the client MAY disconnect from the peer.</p>

<p>A client can then determine if their local record of a peer’s MetaData is up to date
and MAY request an updated version via the <code class="language-plaintext highlighter-rouge">MetaData</code> RPC method if not.</p>

<p>The request MUST be encoded as an SSZ-field.</p>

<p>The response MUST consist of a single <code class="language-plaintext highlighter-rouge">response_chunk</code>.</p>

<h4 id="getmetadata">GetMetaData</h4>

<p><strong>Protocol ID:</strong> <code class="language-plaintext highlighter-rouge">/eth2/beacon_chain/req/metadata/1/</code></p>

<p>No Request Content.</p>

<p>Response Content:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(
  MetaData
)
</code></pre></div></div>

<p>Requests the MetaData of a peer.
The request opens and negotiates the stream without sending any request content.
Once established the receiving peer responds with
it’s local most up-to-date MetaData.</p>

<p>The response MUST be encoded as an SSZ-container.</p>

<p>The response MUST consist of a single <code class="language-plaintext highlighter-rouge">response_chunk</code>.</p>

<h2 id="the-discovery-domain-discv5">The discovery domain: discv5</h2>

<p>Discovery Version 5 (<a href="https://github.com/ethereum/devp2p/blob/master/discv5/discv5.md">discv5</a>) (Protocol version v5.1) is used for peer discovery.</p>

<p><code class="language-plaintext highlighter-rouge">discv5</code> is a standalone protocol, running on UDP on a dedicated port, meant for peer discovery only.
<code class="language-plaintext highlighter-rouge">discv5</code> supports self-certified, flexible peer records (ENRs) and topic-based advertisement, both of which are (or will be) requirements in this context.</p>

<h3 id="integration-into-libp2p-stacks">Integration into libp2p stacks</h3>

<p><code class="language-plaintext highlighter-rouge">discv5</code> SHOULD be integrated into the client’s libp2p stack by implementing an adaptor
to make it conform to the <a href="https://github.com/libp2p/go-libp2p-core/blob/master/discovery/discovery.go">service discovery</a>
and <a href="https://github.com/libp2p/go-libp2p-core/blob/master/routing/routing.go#L36-L44">peer routing</a> abstractions and interfaces (go-libp2p links provided).</p>

<p>Inputs to operations include peer IDs (when locating a specific peer) or capabilities (when searching for peers with a specific capability),
and the outputs will be multiaddrs converted from the ENR records returned by the discv5 backend.</p>

<p>This integration enables the libp2p stack to subsequently form connections and streams with discovered peers.</p>

<h3 id="enr-structure">ENR structure</h3>

<p>The Ethereum Node Record (ENR) for an Ethereum 2.0 client MUST contain the following entries
(exclusive of the sequence number and signature, which MUST be present in an ENR):</p>

<ul>
  <li>The compressed secp256k1 publickey, 33 bytes (<code class="language-plaintext highlighter-rouge">secp256k1</code> field).</li>
</ul>

<p>The ENR MAY contain the following entries:</p>

<ul>
  <li>An IPv4 address (<code class="language-plaintext highlighter-rouge">ip</code> field) and/or IPv6 address (<code class="language-plaintext highlighter-rouge">ip6</code> field).</li>
  <li>A TCP port (<code class="language-plaintext highlighter-rouge">tcp</code> field) representing the local libp2p listening port.</li>
  <li>A UDP port (<code class="language-plaintext highlighter-rouge">udp</code> field) representing the local discv5 listening port.</li>
</ul>

<p>Specifications of these parameters can be found in the <a href="http://eips.ethereum.org/EIPS/eip-778">ENR Specification</a>.</p>

<h4 id="attestation-subnet-bitfield">Attestation subnet bitfield</h4>

<p>The ENR <code class="language-plaintext highlighter-rouge">attnets</code> entry signifies the attestation subnet bitfield with the following form
to more easily discover peers participating in particular attestation gossip subnets.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Key</th>
      <th style="text-align: left">Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">attnets</code></td>
      <td style="text-align: left">SSZ <code class="language-plaintext highlighter-rouge">Bitvector[ATTESTATION_SUBNET_COUNT]</code></td>
    </tr>
  </tbody>
</table>

<p>If a node’s <code class="language-plaintext highlighter-rouge">MetaData.attnets</code> has any non-zero bit, the ENR MUST include the <code class="language-plaintext highlighter-rouge">attnets</code> entry with the same value as <code class="language-plaintext highlighter-rouge">MetaData.attnets</code>.</p>

<p>If a node’s <code class="language-plaintext highlighter-rouge">MetaData.attnets</code> is composed of all zeros, the ENR MAY optionally include the <code class="language-plaintext highlighter-rouge">attnets</code> entry or leave it out entirely.</p>

<h4 id="eth2-field"><code class="language-plaintext highlighter-rouge">eth2</code> field</h4>

<p>ENRs MUST carry a generic <code class="language-plaintext highlighter-rouge">eth2</code> key with an 16-byte value of the node’s current fork digest, next fork version,
and next fork epoch to ensure connections are made with peers on the intended eth2 network.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Key</th>
      <th style="text-align: left">Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">eth2</code></td>
      <td style="text-align: left">SSZ <code class="language-plaintext highlighter-rouge">ENRForkID</code></td>
    </tr>
  </tbody>
</table>

<p>Specifically, the value of the <code class="language-plaintext highlighter-rouge">eth2</code> key MUST be the following SSZ encoded object (<code class="language-plaintext highlighter-rouge">ENRForkID</code>)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(
    fork_digest: ForkDigest
    next_fork_version: Version
    next_fork_epoch: Epoch
)
</code></pre></div></div>

<p>where the fields of <code class="language-plaintext highlighter-rouge">ENRForkID</code> are defined as</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fork_digest</code> is <code class="language-plaintext highlighter-rouge">compute_fork_digest(current_fork_version, genesis_validators_root)</code> where
    <ul>
      <li><code class="language-plaintext highlighter-rouge">current_fork_version</code> is the fork version at the node’s current epoch defined by the wall-clock time
(not necessarily the epoch to which the node is sync)</li>
      <li><code class="language-plaintext highlighter-rouge">genesis_validators_root</code> is the static <code class="language-plaintext highlighter-rouge">Root</code> found in <code class="language-plaintext highlighter-rouge">state.genesis_validators_root</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">next_fork_version</code> is the fork version corresponding to the next planned hard fork at a future epoch.
If no future fork is planned, set <code class="language-plaintext highlighter-rouge">next_fork_version = current_fork_version</code> to signal this fact</li>
  <li><code class="language-plaintext highlighter-rouge">next_fork_epoch</code> is the epoch at which the next fork is planned and the <code class="language-plaintext highlighter-rouge">current_fork_version</code> will be updated.
If no future fork is planned, set <code class="language-plaintext highlighter-rouge">next_fork_epoch = FAR_FUTURE_EPOCH</code> to signal this fact</li>
</ul>

<p><em>Note</em>: <code class="language-plaintext highlighter-rouge">fork_digest</code> is composed of values that are not not known until the genesis block/state are available.
Due to this, clients SHOULD NOT form ENRs and begin peer discovery until genesis values are known.
One notable exception to this rule is the distribution of bootnode ENRs prior to genesis.
In this case, bootnode ENRs SHOULD be initially distributed with <code class="language-plaintext highlighter-rouge">eth2</code> field set as
<code class="language-plaintext highlighter-rouge">ENRForkID(fork_digest=compute_fork_digest(GENESIS_FORK_VERSION, b'\x00'*32), next_fork_version=GENESIS_FORK_VERSION, next_fork_epoch=FAR_FUTURE_EPOCH)</code>.
After genesis values are known, the bootnodes SHOULD update ENRs to participate in normal discovery operations.</p>

<p>Clients SHOULD connect to peers with <code class="language-plaintext highlighter-rouge">fork_digest</code>, <code class="language-plaintext highlighter-rouge">next_fork_version</code>, and <code class="language-plaintext highlighter-rouge">next_fork_epoch</code> that match local values.</p>

<p>Clients MAY connect to peers with the same <code class="language-plaintext highlighter-rouge">fork_digest</code> but a different <code class="language-plaintext highlighter-rouge">next_fork_version</code>/<code class="language-plaintext highlighter-rouge">next_fork_epoch</code>.
Unless <code class="language-plaintext highlighter-rouge">ENRForkID</code> is manually updated to matching prior to the earlier <code class="language-plaintext highlighter-rouge">next_fork_epoch</code> of the two clients,
these connecting clients will be unable to successfully interact starting at the earlier <code class="language-plaintext highlighter-rouge">next_fork_epoch</code>.</p>

<h1 id="design-decision-rationale">Design decision rationale</h1>

<h2 id="transport-1">Transport</h2>

<h3 id="why-are-we-defining-specific-transports">Why are we defining specific transports?</h3>

<p>libp2p peers can listen on multiple transports concurrently, and these can change over time.
Multiaddrs encode not only the address but also the transport to be used to dial.</p>

<p>Due to this dynamic nature, agreeing on specific transports like TCP, QUIC, or WebSockets on paper becomes irrelevant.</p>

<p>However, it is useful to define a minimum baseline for interoperability purposes.</p>

<h3 id="can-clients-support-other-transportshandshakes-than-the-ones-mandated-by-the-spec">Can clients support other transports/handshakes than the ones mandated by the spec?</h3>

<p>Clients may support other transports such as libp2p QUIC, WebSockets, and WebRTC transports, if available in the language of choice.
While interoperability shall not be harmed by lack of such support, the advantages are desirable:</p>

<ul>
  <li>Better latency, performance, and other QoS characteristics (QUIC).</li>
  <li>Paving the way for interfacing with future light clients (WebSockets, WebRTC).</li>
</ul>

<p>The libp2p QUIC transport inherently relies on TLS 1.3 per requirement in section 7
of the <a href="https://tools.ietf.org/html/draft-ietf-quic-transport-22#section-7">QUIC protocol specification</a>
and the accompanying <a href="https://tools.ietf.org/html/draft-ietf-quic-tls-22">QUIC-TLS document</a>.</p>

<p>The usage of one handshake procedure or the other shall be transparent to the Eth2 application layer,
once the libp2p Host/Node object has been configured appropriately.</p>

<h3 id="what-are-the-advantages-of-using-tcpquicwebsockets">What are the advantages of using TCP/QUIC/Websockets?</h3>

<p>TCP is a reliable, ordered, full-duplex, congestion-controlled network protocol that powers much of the Internet as we know it today.
HTTP/1.1 and HTTP/2 run atop TCP.</p>

<p>QUIC is a new protocol that’s in the final stages of specification by the IETF QUIC WG.
It emerged from Google’s SPDY experiment. The QUIC transport is undoubtedly promising.
It’s UDP-based yet reliable, ordered, multiplexed, natively secure (TLS 1.3), reduces latency vs. TCP,
and offers stream-level and connection-level congestion control (thus removing head-of-line blocking),
0-RTT connection establishment, and endpoint migration, amongst other features.
UDP also has better NAT traversal properties than TCP—something we desperately pursue in peer-to-peer networks.</p>

<p>QUIC is being adopted as the underlying protocol for HTTP/3.
This has the potential to award us censorship resistance via deep packet inspection for free.
Provided that we use the same port numbers and encryption mechanisms as HTTP/3, our traffic may be indistinguishable from standard web traffic,
and we may only become subject to standard IP-based firewall filtering—something we can counteract via other mechanisms.</p>

<p>WebSockets and/or WebRTC transports are necessary for interaction with browsers,
and will become increasingly important as we incorporate browser-based light clients to the Eth2 network.</p>

<h3 id="why-do-we-not-just-support-a-single-transport">Why do we not just support a single transport?</h3>

<p>Networks evolve.
Hardcoding design decisions leads to ossification, preventing the evolution of networks alongside the state of the art.
Introducing changes on an ossified protocol is very costly, and sometimes, downright impracticable without causing undesirable breakage.</p>

<p>Modeling for upgradeability and dynamic transport selection from the get-go lays the foundation for a future-proof stack.</p>

<p>Clients can adopt new transports without breaking old ones, and the multi-transport ability enables constrained and sandboxed environments
(e.g. browsers, embedded devices) to interact with the network as first-class citizens via suitable/native transports (e.g. WSS),
without the need for proxying or trust delegation to servers.</p>

<h3 id="why-are-we-not-using-quic-from-the-start">Why are we not using QUIC from the start?</h3>

<p>The QUIC standard is still not finalized (at working draft 22 at the time of writing),
and not all mainstream runtimes/languages have mature, standard, and/or fully-interoperable <a href="https://github.com/quicwg/base-drafts/wiki/Implementations">QUIC support</a>.
One remarkable example is node.js, where the QUIC implementation is <a href="https://github.com/nodejs/quic">in early development</a>.</p>

<p><em>Note</em>: <a href="https://tools.ietf.org/html/draft-ietf-quic-transport-22#section-7">TLS 1.3 is a prerequisite of the QUIC transport</a>,
although an experiment exists to integrate Noise as the QUIC crypto layer: <a href="https://eprint.iacr.org/2019/028">nQUIC</a>.</p>

<p>On the other hand, TLS 1.3 is the newest, simplified iteration of TLS.
Old, insecure, obsolete ciphers and algorithms have been removed, adopting Ed25519 as the sole ECDH key agreement function.
Handshakes are faster, 1-RTT data is supported, and session resumption is a reality, amongst other features.</p>

<h2 id="multiplexing-1">Multiplexing</h2>

<h3 id="why-are-we-using-mplexyamux">Why are we using mplex/yamux?</h3>

<p><a href="https://github.com/hashicorp/yamux/blob/master/spec.md">Yamux</a> is a multiplexer invented by Hashicorp that supports stream-level congestion control.
Implementations exist in a limited set of languages, and it’s not a trivial piece to develop.</p>

<p>Conscious of that, the libp2p community conceptualized <a href="https://github.com/libp2p/specs/blob/master/mplex/README.md">mplex</a>
as a simple, minimal multiplexer for usage with libp2p.
It does not support stream-level congestion control and is subject to head-of-line blocking.</p>

<p>Overlay multiplexers are not necessary with QUIC since the protocol provides native multiplexing,
but they need to be layered atop TCP, WebSockets, and other transports that lack such support.</p>

<h2 id="protocol-negotiation-1">Protocol Negotiation</h2>

<h3 id="when-is-multiselect-20-due-and-why-do-we-plan-to-migrate-to-it">When is multiselect 2.0 due and why do we plan to migrate to it?</h3>

<p>multiselect 2.0 is currently being conceptualized.
The debate started <a href="https://github.com/libp2p/specs/pull/95">on this issue</a>,
but it got overloaded—as it tends to happen with large conceptual OSS discussions that touch the heart and core of a system.</p>

<p>At some point in 2020, we expect a renewed initiative to first define the requirements, constraints, assumptions, and features,
in order to lock in basic consensus upfront and subsequently build on that consensus by submitting a specification for implementation.</p>

<p>We plan to eventually migrate to multiselect 2.0 because it will:</p>

<ol>
  <li>Reduce round trips during connection bootstrapping and stream protocol negotiation.</li>
  <li>Enable efficient one-stream-per-request interaction patterns.</li>
  <li>Leverage <em>push data</em> mechanisms of underlying protocols to expedite negotiation.</li>
  <li>Provide the building blocks for enhanced censorship resistance.</li>
</ol>

<h3 id="what-is-the-difference-between-connection-level-and-stream-level-protocol-negotiation">What is the difference between connection-level and stream-level protocol negotiation?</h3>

<p>All libp2p connections must be authenticated, encrypted, and multiplexed.
Connections using network transports unsupportive of native authentication/encryption and multiplexing (e.g. TCP) need to undergo protocol negotiation to agree on a mutually supported:</p>

<ol>
  <li>authentication/encryption mechanism (such as SecIO, TLS 1.3, Noise).</li>
  <li>overlay multiplexer (such as mplex, Yamux, spdystream).</li>
</ol>

<p>In this specification, we refer to these two as <em>connection-level negotiations</em>.
Transports supporting those features natively (such as QUIC) omit those negotiations.</p>

<p>After successfully selecting a multiplexer, all subsequent I/O happens over <em>streams</em>.
When opening streams, peers pin a protocol to that stream, by conducting <em>stream-level protocol negotiation</em>.</p>

<p>At present, multistream-select 1.0 is used for both types of negotiation,
but multiselect 2.0 will use dedicated mechanisms for connection bootstrapping process and stream protocol negotiation.</p>

<h2 id="encryption">Encryption</h2>

<h3 id="why-are-we-not-supporting-secio">Why are we not supporting SecIO?</h3>

<p>SecIO has been the default encryption layer for libp2p for years.
It is used in IPFS and Filecoin. And although it will be superseded shortly, it is proven to work at scale.</p>

<p>Although SecIO has wide language support, we won’t be using it for mainnet because, amongst other things,
it requires several round trips to be sound, and doesn’t support early data (0-RTT data),
a mechanism that multiselect 2.0 will leverage to reduce round trips during connection bootstrapping.</p>

<p>SecIO is not considered secure for the purposes of this spec.</p>

<h3 id="why-are-we-using-noise">Why are we using Noise?</h3>

<p>Copied from the Noise Protocol Framework <a href="http://www.noiseprotocol.org">website</a>:</p>

<blockquote>
  <p>Noise is a framework for building crypto protocols.
Noise protocols support mutual and optional authentication, identity hiding, forward secrecy, zero round-trip encryption, and other advanced features.</p>
</blockquote>

<p>Noise in itself does not specify a single handshake procedure,
but provides a framework to build secure handshakes based on Diffie-Hellman key agreement with a variety of tradeoffs and guarantees.</p>

<p>Noise handshakes are lightweight and simple to understand,
and are used in major cryptographic-centric projects like WireGuard, I2P, and Lightning.
<a href="https://www.wireguard.com/papers/kobeissi-bhargavan-noise-explorer-2018.pdf">Various</a> <a href="https://eprint.iacr.org/2019/436.pdf">studies</a>
have assessed the stated security goals of several Noise handshakes with positive results.</p>

<h3 id="why-are-we-using-encryption-at-all">Why are we using encryption at all?</h3>

<p>Transport level encryption secures message exchange and provides properties that are useful for privacy, safety, and censorship resistance.
These properties are derived from the following security guarantees that apply to the entire communication between two peers:</p>

<ul>
  <li>Peer authentication: the peer I’m talking to is really who they claim to be and who I expect them to be.</li>
  <li>Confidentiality: no observer can eavesdrop on the content of our messages.</li>
  <li>Integrity: the data has not been tampered with by a third-party while in transit.</li>
  <li>Non-repudiation: the originating peer cannot dispute that they sent the message.</li>
  <li>Depending on the chosen algorithms and mechanisms (e.g. continuous HMAC), we may obtain additional guarantees,
such as non-replayability (this byte could’ve only been sent <em>now;</em> e.g. by using continuous HMACs),
or perfect forward secrecy (in the case that a peer key is compromised, the content of a past conversation will not be compromised).</li>
</ul>

<p>Note that transport-level encryption is not exclusive of application-level encryption or cryptography.
Transport-level encryption secures the communication itself,
while application-level cryptography is necessary for the application’s use cases (e.g. signatures, randomness, etc.).</p>

<h2 id="gossipsub">Gossipsub</h2>

<h3 id="why-are-we-using-a-pubsub-algorithm-for-block-and-attestation-propagation">Why are we using a pub/sub algorithm for block and attestation propagation?</h3>

<p>Pubsub is a technique to broadcast/disseminate data across a network rapidly.
Such data is packaged in fire-and-forget messages that do not require a response from every recipient.
Peers subscribed to a topic participate in the propagation of messages in that topic.</p>

<p>The alternative is to maintain a fully connected mesh (all peers connected to each other 1:1), which scales poorly (O(n^2)).</p>

<h3 id="why-are-we-using-topics-to-segregate-encodings-yet-only-support-one-encoding">Why are we using topics to segregate encodings, yet only support one encoding?</h3>

<p>For future extensibility with almost zero overhead now (besides the extra bytes in the topic name).</p>

<h3 id="how-do-we-upgrade-gossip-channels-eg-changes-in-encoding-compression">How do we upgrade gossip channels (e.g. changes in encoding, compression)?</h3>

<p>Changing gossipsub/broadcasts requires a coordinated upgrade where all clients start publishing to the new topic together, during a hard fork.</p>

<p>When a node is preparing for upcoming tasks (e.g. validator duty lookahead) on a gossipsub topic,
the node should join the topic of the future epoch in which the task is to occur in addition to listening to the topics for the current epoch.</p>

<h3 id="why-must-all-clients-use-the-same-gossip-topic-instead-of-one-negotiated-between-each-peer-pair">Why must all clients use the same gossip topic instead of one negotiated between each peer pair?</h3>

<p>Supporting multiple topics/encodings would require the presence of relayers to translate between encodings
and topics so as to avoid network fragmentation where participants have diverging views on the gossiped state,
making the protocol more complicated and fragile.</p>

<p>Gossip protocols typically remember what messages they’ve seen for a finite period of time-based on message identity
– if you publish the same message again after that time has passed,
it will be re-broadcast—adding a relay delay also makes this scenario more likely.</p>

<p>One can imagine that in a complicated upgrade scenario, we might have peers publishing the same message on two topics/encodings,
but the price here is pretty high in terms of overhead – both computational and networking – so we’d rather avoid that.</p>

<p>It is permitted for clients to publish data on alternative topics as long as they also publish on the network-wide mandatory topic.</p>

<h3 id="why-are-the-topics-strings-and-not-hashes">Why are the topics strings and not hashes?</h3>

<p>Topic names have a hierarchical structure.
In the future, gossipsub may support wildcard subscriptions
(e.g. subscribe to all children topics under a root prefix) by way of prefix matching.
Enforcing hashes for topic names would preclude us from leveraging such features going forward.</p>

<p>No security or privacy guarantees are lost as a result of choosing plaintext topic names,
since the domain is finite anyway, and calculating a digest’s preimage would be trivial.</p>

<p>Furthermore, the Eth2 topic names are shorter than their digest equivalents (assuming SHA-256 hash),
so hashing topics would bloat messages unnecessarily.</p>

<h3 id="why-are-we-using-the-strictnosign-signature-policy">Why are we using the <code class="language-plaintext highlighter-rouge">StrictNoSign</code> signature policy?</h3>

<p>The policy omits the <code class="language-plaintext highlighter-rouge">from</code> (1), <code class="language-plaintext highlighter-rouge">seqno</code> (3), <code class="language-plaintext highlighter-rouge">signature</code> (5) and <code class="language-plaintext highlighter-rouge">key</code> (6) fields. These fields would:</p>
<ul>
  <li>Expose origin of sender (<code class="language-plaintext highlighter-rouge">from</code>), type of sender (based on <code class="language-plaintext highlighter-rouge">seqno</code>)</li>
  <li>Add extra unused data to the gossip, since message IDs are based on <code class="language-plaintext highlighter-rouge">data</code>, not on the <code class="language-plaintext highlighter-rouge">from</code> and <code class="language-plaintext highlighter-rouge">seqno</code>.</li>
  <li>Introduce more message validation than necessary, e.g. no <code class="language-plaintext highlighter-rouge">signature</code>.</li>
</ul>

<h3 id="why-are-we-overriding-the-default-libp2p-pubsub-message-id">Why are we overriding the default libp2p pubsub <code class="language-plaintext highlighter-rouge">message-id</code>?</h3>

<p>For our current purposes, there is no need to address messages based on source peer, or track a message <code class="language-plaintext highlighter-rouge">seqno</code>.
By overriding the default <code class="language-plaintext highlighter-rouge">message-id</code> to use content-addressing we can filter unnecessary duplicates before hitting the application layer.</p>

<p>Some examples of where messages could be duplicated:</p>

<ul>
  <li>A validator client connected to multiple beacon nodes publishing duplicate gossip messages</li>
  <li>Attestation aggregation strategies where clients partially aggregate attestations and propagate them.
Partial aggregates could be duplicated</li>
  <li>Clients re-publishing seen messages</li>
</ul>

<h3 id="why-are-these-specific-gossip-parameters-chosen">Why are these specific gossip parameters chosen?</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">D</code>, <code class="language-plaintext highlighter-rouge">D_low</code>, <code class="language-plaintext highlighter-rouge">D_high</code>, <code class="language-plaintext highlighter-rouge">D_lazy</code>: recommended defaults.</li>
  <li><code class="language-plaintext highlighter-rouge">heartbeat_interval</code>: 0.7 seconds, recommended for eth2 in the <a href="https://gateway.ipfs.io/ipfs/QmRAFP5DBnvNjdYSbWhEhVRJJDFCLpPyvew5GwCCB4VxM4">GossipSub evaluation report by Protocol Labs</a>.</li>
  <li><code class="language-plaintext highlighter-rouge">fanout_ttl</code>: 60 seconds, recommended default.
Fanout is primarily used by committees publishing attestations to subnets.
This happens once per epoch per validator and the subnet changes each epoch
so there is little to gain in having a <code class="language-plaintext highlighter-rouge">fanout_ttl</code> be increased from the recommended default.</li>
  <li><code class="language-plaintext highlighter-rouge">mcache_len</code>: 6, increase by one to ensure that mcache is around for long
enough for <code class="language-plaintext highlighter-rouge">IWANT</code>s to respond to <code class="language-plaintext highlighter-rouge">IHAVE</code>s in the context of the shorter
<code class="language-plaintext highlighter-rouge">heartbeat_interval</code>. If <code class="language-plaintext highlighter-rouge">mcache_gossip</code> is increased, this param should be
increased to be at least <code class="language-plaintext highlighter-rouge">3</code> (~2 seconds) more than <code class="language-plaintext highlighter-rouge">mcache_gossip</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">mcache_gossip</code>: 3, recommended default. This can be increased to 5 or 6
(~4 seconds) if gossip times are longer than expected and the current window
does not provide enough responsiveness during adverse conditions.</li>
  <li><code class="language-plaintext highlighter-rouge">seen_ttl</code>: <code class="language-plaintext highlighter-rouge">SLOTS_PER_EPOCH * SECONDS_PER_SLOT / heartbeat_interval = approx. 550</code>.
Attestation gossip validity is bounded by an epoch, so this is the safe max bound.</li>
</ul>

<h3 id="why-is-there-maximum_gossip_clock_disparity-when-validating-slot-ranges-of-messages-in-gossip-subnets">Why is there <code class="language-plaintext highlighter-rouge">MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> when validating slot ranges of messages in gossip subnets?</h3>

<p>For some gossip channels (e.g. those for Attestations and BeaconBlocks),
there are designated ranges of slots during which particular messages can be sent,
limiting messages gossiped to those that can be reasonably used in the consensus at the current time/slot.
This is to reduce optionality in DoS attacks.</p>

<p><code class="language-plaintext highlighter-rouge">MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> provides some leeway in validating slot ranges to prevent the gossip network
from becoming overly brittle with respect to clock disparity.
For minimum and maximum allowable slot broadcast times,
<code class="language-plaintext highlighter-rouge">MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> MUST be subtracted and added respectively, marginally extending the valid range.
Although messages can at times be eagerly gossiped to the network,
the node’s fork choice prevents integration of these messages into the actual consensus until the <em>actual local start</em> of the designated slot.</p>

<h3 id="why-are-there-attestation_subnet_count-attestation-subnets">Why are there <code class="language-plaintext highlighter-rouge">ATTESTATION_SUBNET_COUNT</code> attestation subnets?</h3>

<p>Depending on the number of validators, it may be more efficient to group shard subnets and might provide better stability for the gossipsub channel.
The exact grouping will be dependent on more involved network tests.
This constant allows for more flexibility in setting up the network topology for attestation aggregation (as aggregation should happen on each subnet).
The value is currently set to to be equal <code class="language-plaintext highlighter-rouge">MAX_COMMITTEES_PER_SLOT</code> if/until network tests indicate otherwise.</p>

<h3 id="why-are-attestations-limited-to-be-broadcast-on-gossip-channels-within-slots_per_epoch-slots">Why are attestations limited to be broadcast on gossip channels within <code class="language-plaintext highlighter-rouge">SLOTS_PER_EPOCH</code> slots?</h3>

<p>Attestations can only be included on chain within an epoch’s worth of slots so this is the natural cutoff.
There is no utility to the chain to broadcast attestations older than one epoch,
and because validators have a chance to make a new attestation each epoch,
there is minimal utility to the fork choice to relay old attestations as a new latest message can soon be created by each validator.</p>

<p>In addition to this, relaying attestations requires validating the attestation in the context of the <code class="language-plaintext highlighter-rouge">state</code> during which it was created.
Thus, validating arbitrarily old attestations would put additional requirements on which states need to be readily available to the node.
This would result in a higher resource burden and could serve as a DoS vector.</p>

<h3 id="why-are-aggregate-attestations-broadcast-to-the-global-topic-as-aggregateandproofs-rather-than-just-as-attestations">Why are aggregate attestations broadcast to the global topic as <code class="language-plaintext highlighter-rouge">AggregateAndProof</code>s rather than just as <code class="language-plaintext highlighter-rouge">Attestation</code>s?</h3>

<p>The dominant strategy for an individual validator is to always broadcast an aggregate containing their own attestation
to the global channel to ensure that proposers see their attestation for inclusion.
Using a private selection criteria and providing this proof of selection alongside
the gossiped aggregate ensures that this dominant strategy will not flood the global channel.</p>

<p>Also, an attacker can create any number of honest-looking aggregates and broadcast them to the global pubsub channel.
Thus without some sort of proof of selection as an aggregator, the global channel can trivially be spammed.</p>

<h3 id="why-are-we-sending-entire-objects-in-the-pubsub-and-not-just-hashes">Why are we sending entire objects in the pubsub and not just hashes?</h3>

<p>Entire objects should be sent to get the greatest propagation speeds.
If only hashes are sent, then block and attestation propagation is dependent on recursive requests from each peer.
In a hash-only scenario, peers could receive hashes without knowing who to download the actual contents from.
Sending entire objects ensures that they get propagated through the entire network.</p>

<h3 id="should-clients-gossip-blocks-if-they-cannot-validate-the-proposer-signature-due-to-not-yet-being-synced-not-knowing-the-head-block-etc">Should clients gossip blocks if they <em>cannot</em> validate the proposer signature due to not yet being synced, not knowing the head block, etc?</h3>

<p>The prohibition of unverified-block-gossiping extends to nodes that cannot verify a signature
due to not being fully synced to ensure that such (amplified) DOS attacks are not possible.</p>

<h3 id="how-are-we-going-to-discover-peers-in-a-gossipsub-topic">How are we going to discover peers in a gossipsub topic?</h3>

<p>In Phase 0, peers for attestation subnets will be found using the <code class="language-plaintext highlighter-rouge">attnets</code> entry in the ENR.</p>

<p>Although this method will be sufficient for early phases of Eth2, we aim to use the more appropriate discv5 topics for this and other similar tasks in the future.
ENRs should ultimately not be used for this purpose.
They are best suited to store identity, location, and capability information, rather than more volatile advertisements.</p>

<h3 id="how-should-fork-version-be-used-in-practice">How should fork version be used in practice?</h3>

<p>Fork versions are to be manually updated (likely via incrementing) at each hard fork.
This is to provide native domain separation for signatures as well as to aid in usefulness for identitying peers (via ENRs)
and versioning network protocols (e.g. using fork version to naturally version gossipsub topics).</p>

<p><code class="language-plaintext highlighter-rouge">BeaconState.genesis_validators_root</code> is mixed into signature and ENR fork domains (<code class="language-plaintext highlighter-rouge">ForkDigest</code>) to aid in the ease of domain separation between chains.
This allows fork versions to safely be reused across chains except for the case of contentious forks using the same genesis.
In these cases, extra care should be taken to isolate fork versions (e.g. flip a high order bit in all future versions of one of the chains).</p>

<p>A node locally stores all previous and future planned fork versions along with the each fork epoch.
This allows for handling sync and processing messages starting from past forks/epochs.</p>

<h2 id="reqresp">Req/Resp</h2>

<h3 id="why-segregate-requests-into-dedicated-protocol-ids">Why segregate requests into dedicated protocol IDs?</h3>

<p>Requests are segregated by protocol ID to:</p>

<ol>
  <li>Leverage protocol routing in libp2p, such that the libp2p stack will route the incoming stream to the appropriate handler.
  This allows the handler function for each request type to be self-contained.
  For an analogy, think about how you attach HTTP handlers to a REST API server.</li>
  <li>Version requests independently.
  In a coarser-grained umbrella protocol, the entire protocol would have to be versioned even if just one field in a single message changed.</li>
  <li>Enable clients to select the individual requests/versions they support.
  It would no longer be a strict requirement to support all requests,
  and clients, in principle, could support a subset of requests and variety of versions.</li>
  <li>Enable flexibility and agility for clients adopting spec changes that impact the request, by signalling to peers exactly which subset of new/old requests they support.</li>
  <li>Enable clients to explicitly choose backwards compatibility at the request granularity.
  Without this, clients would be forced to support entire versions of the coarser request protocol.</li>
  <li>Parallelise RFCs (or Eth2 EIPs).
  By decoupling requests from one another, each RFC that affects the request protocol can be deployed/tested/debated independently
  without relying on a synchronization point to version the general top-level protocol.</li>
  <li>This has the benefit that clients can explicitly choose which RFCs to deploy
    without buying into all other RFCs that may be included in that top-level version.</li>
  <li>Affording this level of granularity with a top-level protocol would imply creating as many variants
    (e.g. /protocol/43-{a,b,c,d,…}) as the cartesian product of RFCs inflight, O(n^2).</li>
  <li>Allow us to simplify the payload of requests.
  Request-id’s and method-ids no longer need to be sent.
  The encoding/request type and version can all be handled by the framework.</li>
</ol>

<p><strong>Caveat</strong>: The protocol negotiation component in the current version of libp2p is called multistream-select 1.0.
It is somewhat naïve and introduces overhead on every request when negotiating streams,
although implementation-specific optimizations are possible to save this cost.
Multiselect 2.0 will eventually remove this overhead by memoizing previously selected protocols, and modeling shared protocol tables.
Fortunately, this req/resp protocol is not the expected network bottleneck in the protocol
so the additional overhead is not expected to significantly hinder this domain.</p>

<h3 id="why-are-messages-length-prefixed-with-a-protobuf-varint-in-the-ssz-encoding">Why are messages length-prefixed with a protobuf varint in the SSZ-encoding?</h3>

<p>We are using single-use streams where each stream is closed at the end of the message.
Thus, libp2p transparently handles message delimiting in the underlying stream.
libp2p streams are full-duplex, and each party is responsible for closing their write side (like in TCP).
We can therefore use stream closure to mark the end of the request and response independently.</p>

<p>Nevertheless, in the case of <code class="language-plaintext highlighter-rouge">ssz_snappy</code>, messages are still length-prefixed with the length of the underlying data:</p>
<ul>
  <li>A basic reader can prepare a correctly sized buffer before reading the message</li>
  <li>A more advanced reader can stream-decode SSZ given the length of the SSZ data.</li>
  <li>Alignment with protocols like gRPC over HTTP/2 that prefix with length</li>
  <li>Sanity checking of message length, and enabling much stricter message length limiting based on SSZ type information,
to provide even more DOS protection than the global message length already does.
E.g. a small <code class="language-plaintext highlighter-rouge">Status</code> message does not nearly require <code class="language-plaintext highlighter-rouge">MAX_CHUNK_SIZE</code> bytes.</li>
</ul>

<p><a href="https://developers.google.com/protocol-buffers/docs/encoding#varints">Protobuf varint</a> is an efficient technique to encode variable-length (unsigned here) ints.
Instead of reserving a fixed-size field of as many bytes as necessary to convey the maximum possible value, this field is elastic in exchange for 1-bit overhead per byte.</p>

<h3 id="why-do-we-version-protocol-strings-with-ordinals-instead-of-semver">Why do we version protocol strings with ordinals instead of semver?</h3>

<p>Using semver for network protocols is confusing.
It is never clear what a change in a field, even if backwards compatible on deserialization, actually implies.
Network protocol agreement should be explicit. Imagine two peers:</p>

<ul>
  <li>Peer A supporting v1.1.1 of protocol X.</li>
  <li>Peer B supporting v1.1.2 of protocol X.</li>
</ul>

<p>These two peers should never speak to each other because the results can be unpredictable.
This is an oversimplification: imagine the same problem with a set of 10 possible versions.
We now have 10^2 (100) possible outcomes that peers need to model for. The resulting complexity is unwieldy.</p>

<p>For this reason, we rely on negotiation of explicit, verbatim protocols.
In the above case, peer B would provide backwards compatibility by supporting and advertising both v1.1.1 and v1.1.2 of the protocol.</p>

<p>Therefore, semver would be relegated to convey expectations at the human level, and it wouldn’t do a good job there either,
because it’s unclear if “backwards compatibility” and “breaking change” apply only to wire schema level, to behavior, etc.</p>

<p>For this reason, we remove and replace semver with ordinals that require explicit agreement and do not mandate a specific policy for changes.</p>

<h3 id="why-is-it-called-reqresp-and-not-rpc">Why is it called Req/Resp and not RPC?</h3>

<p>Req/Resp is used to avoid confusion with JSON-RPC and similar user-client interaction mechanisms.</p>

<h3 id="why-do-we-allow-empty-responses-in-block-requests">Why do we allow empty responses in block requests?</h3>

<p>When requesting blocks by range or root, it may happen that there are no blocks in the selected range or the responding node does not have the requested blocks.</p>

<p>Thus, it may happen that we need to transmit an empty list - there are several ways to encode this:</p>

<p>0) Close the stream without sending any data
1) Add a <code class="language-plaintext highlighter-rouge">null</code> option to the <code class="language-plaintext highlighter-rouge">success</code> response, for example by introducing an additional byte
2) Respond with an error result, using a specific error code for “No data”</p>

<p>Semantically, it is not an error that a block is missing during a slot making option 2 unnatural.</p>

<p>Option 1 allows allows the responder to signal “no block”, but this information may be wrong - for example in the case of a malicious node.</p>

<p>Under option 0, there is no way for a client to distinguish between a slot without a block and an incomplete response,
but given that it already must contain logic to handle the uncertainty of a malicious peer, option 0 was chosen.
Clients should mark any slots missing blocks as unknown until they can be verified as not containing a block by successive blocks.</p>

<p>Assuming option 0 with no special <code class="language-plaintext highlighter-rouge">null</code> encoding, consider a request for slots <code class="language-plaintext highlighter-rouge">2, 3, 4</code>
– if there was no block produced at slot 4, the response would be <code class="language-plaintext highlighter-rouge">2, 3, EOF</code>.
Now consider the same situation, but where only <code class="language-plaintext highlighter-rouge">4</code> is requested
– closing the stream with only <code class="language-plaintext highlighter-rouge">EOF</code> (without any <code class="language-plaintext highlighter-rouge">response_chunk</code>) is consistent.</p>

<p>Failing to provide blocks that nodes “should” have is reason to trust a peer less
– for example, if a particular peer gossips a block, it should have access to its parent.
If a request for the parent fails, it’s indicative of poor peer quality since peers should validate blocks before gossiping them.</p>

<h3 id="why-does-beaconblocksbyrange-let-the-server-choose-which-branch-to-send-blocks-from">Why does <code class="language-plaintext highlighter-rouge">BeaconBlocksByRange</code> let the server choose which branch to send blocks from?</h3>

<p>When connecting, the <code class="language-plaintext highlighter-rouge">Status</code> message gives an idea about the sync status of a particular peer, but this changes over time.
By the time a subsequent <code class="language-plaintext highlighter-rouge">BeaconBlockByRange</code> request is processed, the information may be stale,
and the responding side might have moved on to a new finalization point and pruned blocks around the previous head and finalized blocks.</p>

<p>To avoid this race condition, we allow the responding side to choose which branch to send to the requesting client.
The requesting client then goes on to validate the blocks and incorporate them in their own database
– because they follow the same rules, they should at this point arrive at the same canonical chain.</p>

<h3 id="whats-the-effect-of-empty-slots-on-the-sync-algorithm">What’s the effect of empty slots on the sync algorithm?</h3>

<p>When syncing one can only tell that a slot has been skipped on a particular branch
by examining subsequent blocks and analyzing the graph formed by the parent root.
Because the server side may choose to omit blocks in the response for any reason, clients must validate the graph and be prepared to fill in gaps.</p>

<p>For example, if a peer responds with blocks [2, 3] when asked for [2, 3, 4], clients may not assume that block 4 doesn’t exist
– it merely means that the responding peer did not send it (they may not have it yet or may maliciously be trying to hide it)
and successive blocks will be needed to determine if there exists a block at slot 4 in this particular branch.</p>

<h2 id="discovery">Discovery</h2>

<h3 id="why-are-we-using-discv5-and-not-libp2p-kademlia-dht">Why are we using discv5 and not libp2p Kademlia DHT?</h3>

<p>discv5 is a standalone protocol, running on UDP on a dedicated port, meant for peer and service discovery only.
discv5 supports self-certified, flexible peer records (ENRs) and topic-based advertisement, both of which are, or will be, requirements in this context.</p>

<p>On the other hand, libp2p Kademlia DHT is a fully-fledged DHT protocol/implementations
with content routing and storage capabilities, both of which are irrelevant in this context.</p>

<p>Eth 1.0 nodes will evolve to support discv5.
By sharing the discovery network between Eth 1.0 and 2.0,
we benefit from the additive effect on network size that enhances resilience and resistance against certain attacks,
to which smaller networks are more vulnerable.
It should also help light clients of both networks find nodes with specific capabilities.</p>

<p>discv5 is in the process of being audited.</p>

<h3 id="what-is-the-difference-between-an-enr-and-a-multiaddr-and-why-are-we-using-enrs">What is the difference between an ENR and a multiaddr, and why are we using ENRs?</h3>

<p>Ethereum Node Records are self-certified node records.
Nodes craft and disseminate ENRs for themselves, proving authorship via a cryptographic signature.
ENRs are sequentially indexed, enabling conflicts to be resolved.</p>

<p>ENRs are key-value records with string-indexed ASCII keys.
They can store arbitrary information, but EIP-778 specifies a pre-defined dictionary, including IPv4 and IPv6 addresses, secp256k1 public keys, etc.</p>

<p>Comparing ENRs and multiaddrs is like comparing apples and oranges.
ENRs are self-certified containers of identity, addresses, and metadata about a node.
Multiaddrs are address strings with the peculiarity that they’re self-describing, composable and future-proof.
An ENR can contain multiaddrs, and multiaddrs can be derived securely from the fields of an authenticated ENR.</p>

<p>discv5 uses ENRs and we will presumably need to:</p>

<ol>
  <li>Add <code class="language-plaintext highlighter-rouge">multiaddr</code> to the dictionary, so that nodes can advertise their multiaddr under a reserved namespace in ENRs. – and/or –</li>
  <li>Define a bi-directional conversion function between multiaddrs and the corresponding denormalized fields in an ENR
  (ip, ip6, tcp, tcp6, etc.), for compatibility with nodes that do not support multiaddr natively (e.g. Eth 1.0 nodes).</li>
</ol>

<h3 id="why-do-we-not-form-enrs-and-find-peers-until-genesis-blockstate-is-known">Why do we not form ENRs and find peers until genesis block/state is known?</h3>

<p>Although client software might very well be running locally prior to the solidification of the eth2 genesis state and block,
clients cannot form valid ENRs prior to this point.
ENRs contain <code class="language-plaintext highlighter-rouge">fork_digest</code> which utilizes the <code class="language-plaintext highlighter-rouge">genesis_validators_root</code> for a cleaner separation between chains
so prior to knowing genesis, we cannot use <code class="language-plaintext highlighter-rouge">fork_digest</code> to cleanly find peers on our intended chain.
Once genesis data is known, we can then form ENRs and safely find peers.</p>

<p>When using an eth1 deposit contract for deposits, <code class="language-plaintext highlighter-rouge">fork_digest</code> will be known <code class="language-plaintext highlighter-rouge">GENESIS_DELAY</code> (7 days in mainnet configuration) before <code class="language-plaintext highlighter-rouge">genesis_time</code>,
providing ample time to find peers and form initial connections and gossip subnets prior to genesis.</p>

<h2 id="compressionencoding">Compression/Encoding</h2>

<h3 id="why-are-we-using-ssz-for-encoding">Why are we using SSZ for encoding?</h3>

<p>SSZ is used at the consensus layer, and all implementations should have support for SSZ-encoding/decoding,
requiring no further dependencies to be added to client implementations.
This is a natural choice for serializing objects to be sent across the wire.
The actual data in most protocols will be further compressed for efficiency.</p>

<p>SSZ has well-defined schemas for consensus objects (typically sent across the wire) reducing any serialization schema data that needs to be sent.
It also has defined all required types that are required for this network specification.</p>

<h3 id="why-are-we-compressing-and-at-which-layers">Why are we compressing, and at which layers?</h3>

<p>We compress on the wire to achieve smaller payloads per-message, which, in aggregate,
result in higher efficiency, better utilization of available bandwidth, and overall reduction in network-wide traffic overhead.</p>

<p>At this time, libp2p does not have an out-of-the-box compression feature that can be dynamically negotiated
and layered atop connections and streams, but it is <a href="https://github.com/libp2p/libp2p/issues/81">being considered</a>.</p>

<p>This is a non-trivial feature because the behavior
of network IO loops, kernel buffers, chunking, and packet fragmentation, amongst others, need to be taken into account.
libp2p streams are unbounded streams, whereas compression algorithms work best on bounded byte streams of which we have some prior knowledge.</p>

<p>Compression tends not to be a one-size-fits-all problem.
A lot of variables need careful evaluation, and generic approaches/choices lead to poor size shavings,
which may even be counterproductive when factoring in the CPU and memory tradeoff.</p>

<p>For all these reasons, generically negotiating compression algorithms may be treated as a research problem at the libp2p community,
one we’re happy to tackle in the medium-term.</p>

<p>At this stage, the wisest choice is to consider libp2p a messenger of bytes,
and to make application layer participate in compressing those bytes.
This looks different depending on the interaction layer:</p>

<ul>
  <li>Gossip domain: since gossipsub has a framing protocol and exposes an API, we compress the payload
(when dictated by the encoding token in the topic name) prior to publishing the message via the API.
No length-prefixing is necessary because protobuf takes care of bounding the field in the serialized form.</li>
  <li>Req/Resp domain: since we define custom protocols that operate on byte streams,
implementers are encouraged to encapsulate the encoding and compression logic behind
MessageReader and MessageWriter components/strategies that can be layered on top of the raw byte streams.</li>
</ul>

<h3 id="why-are-using-snappy-for-compression">Why are using Snappy for compression?</h3>

<p>Snappy is used in Ethereum 1.0. It is well maintained by Google, has good benchmarks,
and can calculate the size of the uncompressed object without inflating it in memory.
This prevents DOS vectors where large uncompressed data is sent.</p>

<h3 id="can-i-get-access-to-unencrypted-bytes-on-the-wire-for-debugging-purposes">Can I get access to unencrypted bytes on the wire for debugging purposes?</h3>

<p>Yes, you can add loggers in your libp2p protocol handlers to log incoming and outgoing messages.
It is recommended to use programming design patterns to encapsulate the logging logic cleanly.</p>

<p>If your libp2p library relies on frameworks/runtimes such as Netty (jvm) or Node.js (javascript),
you can use logging facilities in those frameworks/runtimes to enable message tracing.</p>

<p>For specific ad-hoc testing scenarios, you can use the <a href="https://github.com/libp2p/specs/blob/master/plaintext/README.md">plaintext/2.0.0 secure channel</a>
(which is essentially no-op encryption or message authentication), in combination with tcpdump or Wireshark to inspect the wire.</p>

<h3 id="what-are-ssz-type-size-bounds">What are SSZ type size bounds?</h3>

<p>The SSZ encoding outputs of each type have size bounds: each dynamic type, such as a list, has a “limit”, which can be used to compute the maximum valid output size.
Note that for some more complex dynamic-length objects, element offsets (4 bytes each) may need to be included.
Other types are static, they have a fixed size: no dynamic-length content is involved, and the minimum and maximum bounds are the same.</p>

<p>For reference, the type bounds can be computed ahead of time, <a href="https://gist.github.com/protolambda/db75c7faa1e94f2464787a480e5d613e">as per this example</a>.
It is advisable to derive these lengths from the SSZ type definitions in use, to ensure that version changes do not cause out-of-sync type bounds.</p>

<h1 id="libp2p-implementations-matrix">libp2p implementations matrix</h1>

<p>This section will soon contain a matrix showing the maturity/state of the libp2p features required
by this spec across the languages in which Eth2 clients are being developed.</p>



<p>
	<strong> SSZ SimpleSerialize for Eth2 </strong>
</p>


